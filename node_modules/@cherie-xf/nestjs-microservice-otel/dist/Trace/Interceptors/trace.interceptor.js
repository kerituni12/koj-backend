"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TraceInterceptor_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceInterceptor = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const operators_1 = require("rxjs/operators");
const api_1 = require("@opentelemetry/api");
const storeContext_model_1 = require("./storeContext.model");
let TraceInterceptor = TraceInterceptor_1 = class TraceInterceptor {
    intercept(ctx, next) {
        const reflector = new core_1.Reflector();
        const except = reflector.get('ExceptTracerInterceptor', ctx.getHandler());
        if (except)
            return next.handle();
        const _logger = new common_1.Logger(TraceInterceptor_1.name);
        const tracer = api_1.trace.getTracer('default');
        if (!tracer)
            return next.handle();
        const getRPCSpan = (ctx) => {
            const tcpContext = ctx.switchToRpc().getContext();
            const patternStr = tcpContext.getPattern();
            const data = ctx.switchToRpc().getData();
            const methodKey = ctx.getHandler().name;
            const className = ctx.getClass().name;
            const parentCtx = api_1.propagation.extract(api_1.context.active(), data, api_1.defaultTextMapGetter);
            const currentSpan = api_1.trace.getSpan(api_1.context.active()) ??
                tracer.startSpan(patternStr, undefined, parentCtx);
            currentSpan.updateName(`${className} -> ${methodKey}`);
            _logger.log(`traceid: ${currentSpan.spanContext().traceId}`);
            storeContext_model_1.StoreContext.cls.enterWith(new storeContext_model_1.StoreContext(parentCtx));
            return currentSpan;
        };
        const getHTTPSpan = (ctx) => {
            const req = ctx.switchToHttp().getRequest();
            const host = req.hostname;
            const path = req.path;
            _logger.log(`httpSpan: ${host} ${path}`);
            const span = api_1.trace.getSpan(api_1.context.active()) ?? tracer.startSpan(host + path);
            span.updateName(`${host}${path}`);
            _logger.log(`traceid: ${span.spanContext().traceId}`);
            span.setAttribute('request.body', JSON.stringify(req.body) || 'UNKNOW');
            span.setAttribute('request.query', JSON.stringify(req.query) || 'UNKNOW');
            return span;
        };
        const span = ctx.getType() === 'rpc' ? getRPCSpan(ctx) : getHTTPSpan(ctx);
        if (!span)
            return next.handle();
        span.addEvent('create span in tracer.micro');
        api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
        });
        return next.handle().pipe((0, operators_1.tap)(() => {
            span.end();
        }));
    }
};
TraceInterceptor = TraceInterceptor_1 = __decorate([
    (0, common_1.Injectable)()
], TraceInterceptor);
exports.TraceInterceptor = TraceInterceptor;
//# sourceMappingURL=trace.interceptor.js.map