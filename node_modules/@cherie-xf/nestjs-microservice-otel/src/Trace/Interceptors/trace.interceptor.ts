import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import {
  context,
  trace,
  propagation,
  defaultTextMapGetter,
} from '@opentelemetry/api';
import { TcpContext } from '@nestjs/microservices';
import { Request as ExpressReq, Response as ExpressRes } from 'express';
import { StoreContext } from './storeContext.model';
@Injectable()
export class TraceInterceptor implements NestInterceptor {
  intercept(
    ctx: ExecutionContext,
    next: CallHandler<any>,
  ): Observable<any> | Promise<Observable<any>> {
    //////////////////////////////////////////////////////////////////
    // handle metadata
    const reflector = new Reflector();
    const except = reflector.get<boolean>(
      'ExceptTracerInterceptor',
      ctx.getHandler(),
    );
    if (except) return next.handle();
    ////////////////////////////////////////////////////////////////////
    const _logger = new Logger(TraceInterceptor.name);

    const tracer = trace.getTracer('default');
    if (!tracer) return next.handle();

    const getRPCSpan = (ctx: ExecutionContext) => {
      const tcpContext = ctx.switchToRpc().getContext<TcpContext>();
      const patternStr = tcpContext.getPattern();
      const data = ctx.switchToRpc().getData();
      const methodKey = ctx.getHandler().name;
      const className = ctx.getClass().name;
      const parentCtx = propagation.extract(
        context.active(),
        data,
        defaultTextMapGetter,
      );

      const currentSpan =
        trace.getSpan(context.active()) ??
        tracer.startSpan(patternStr, undefined, parentCtx);
      currentSpan.updateName(`${className} -> ${methodKey}`);

      _logger.log(`traceid: ${currentSpan.spanContext().traceId}`);
      StoreContext.cls.enterWith(new StoreContext(parentCtx));
      return currentSpan;
    };
    const getHTTPSpan = (ctx: ExecutionContext) => {
      const req: ExpressReq = ctx.switchToHttp().getRequest();
      // const res: ExpressRes = ctx.switchToHttp().getResponse();

      // ** instrumentation-http wll auto inject and extract parentCtx
      // const parentCtx = Array.isArray(req.headers.spanContext)
      //   ? req.headers.spanContext[0]
      //   : req.headers.spanContext;
      // const traceCtx = parentCtx
      //   ? trace.setSpanContext(context.active(), JSON.parse(parentCtx))
      //   : undefined;
      const host = req.hostname;
      const path = req.path;
      _logger.log(`httpSpan: ${host} ${path}`);
      const span =
        trace.getSpan(context.active()) ?? tracer.startSpan(host + path);
      span.updateName(`${host}${path}`);
      _logger.log(`traceid: ${span.spanContext().traceId}`);
      span.setAttribute('request.body', JSON.stringify(req.body) || 'UNKNOW');
      span.setAttribute('request.query', JSON.stringify(req.query) || 'UNKNOW');

      return span;
    };
    const span = ctx.getType() === 'rpc' ? getRPCSpan(ctx) : getHTTPSpan(ctx);

    if (!span) return next.handle();
    span.addEvent('create span in tracer.micro');
    context.with(trace.setSpan(context.active(), span), () => {
      // const currentSpan = trace.getSpan(context.active());
      // _logger.log(
      //   'TraceInterceptor pattern context set to current span',
      //   currentSpan.spanContext(),
      // );
    });
    return next.handle().pipe(
      tap(() => {
        console.log('end of span ')
        span.end();
      }),
    );
  }
}
