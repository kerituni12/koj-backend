// import { ClientProxy, ReadPacket, WritePacket } from '@nestjs/microservices';
import {
  context,
  defaultTextMapSetter,
  propagation,
  trace,
} from '@opentelemetry/api';
// import { Observable } from 'rxjs';

// export class TraceClientProxy extends ClientProxy {
//   async connect(): Promise<any> {
//     console.log('connect');
//   }

//   async close() {
//     console.log('close');
//   }
//   async dispatchEvent(packet: ReadPacket<any>): Promise<any> {
//     return console.log('event to dispatch: ', packet);
//   }

//   publish(
//     packet: ReadPacket<any>,
//     callback: (packet: WritePacket<any>) => void,
//   ) {
//     console.log('message:', packet);

//     // In a real-world application, the "callback" function should be executed
//     // with payload sent back from the responder. Here, we'll simply simulate (5 seconds delay)
//     // that response came through by passing the same "data" as we've originally passed in.
//     callback({ response: packet.data });

//     return () => console.log('teardown');
//   }

//   public traceSend<TResult = any, TInput = any>(
//     pattern: any,
//     data: TInput,
//   ): Observable<TResult> {
//     // In a real-world application, the "callback" function should be executed
//     // with payload sent back from the responder. Here, we'll simply simulate (5 seconds delay)
//     // that response came through by passing the same "data" as we've originally passed in.
//     const span = trace.getSpan(context.active());
//     if (span?.spanContext()) {
//       propagation.inject(context.active(), data, defaultTextMapSetter);
//     }

//     return super.send(pattern, data);
//   }
// }

import { Injectable } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { lastValueFrom, map } from 'rxjs';

@Injectable()
export class TraceClientProxy {
  async send(client: ClientProxy, pattern, payload) {
    const span = trace.getSpan(context.active());
    if (span?.spanContext()) {
      propagation.inject(context.active(), payload, defaultTextMapSetter);
    }
    const res = await lastValueFrom(
      client.send(pattern, payload).pipe(map((data) => data)),
    );
    // console.log('============traceClientProxy', pattern, payload);
    return res;
  }
}
