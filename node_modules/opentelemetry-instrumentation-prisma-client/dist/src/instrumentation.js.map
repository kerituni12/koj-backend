{"version":3,"file":"instrumentation.js","sourceRoot":"","sources":["../../src/instrumentation.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,0DAA6D;AAC7D,oEAKwC;AACxC,8EAAyE;AAIzE,uCAAoC;AAEpC,MAAa,2BAA4B,SAAQ,qCAAmB;IAClE,YAAY,SAAgC,EAAE;QAC5C,KAAK,CAAC,6BAA6B,EAAE,iBAAO,EAAE,MAAM,CAAC,CAAC;IACxD,CAAC;IAES,IAAI;QACZ,MAAM,kBAAkB,GAAG,IAAI,qDAAmC,CAChE,gBAAgB,EAChB,CAAC,GAAG,CAAC,EACL,CAAC,aAAkC,EAAE,EAAE;YACrC,MAAM,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC,SAAgB,CAAC;YAEjE,WAAW;YACX,IAAI,IAAA,2BAAS,EAAC,YAAY,CAAC,UAAU,CAAC,CAAC,EAAE;gBACvC,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;aACxC;YACD,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,UAAU,EAAE,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;YAE3D,OAAO,aAAa,CAAC;QACvB,CAAC,EACD,CAAC,aAAkC,EAAE,EAAE;YACrC,MAAM,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC,SAAgB,CAAC;YACjE,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;QACzC,CAAC,CACF,CAAC;QAEF,OAAO,CAAC,kBAAkB,CAAC,CAAC;IAC9B,CAAC;IAEO,aAAa;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC;QACpB,OAAO,UAAU,QAAmB;YAClC,OAAO,SAAS,cAAc;gBAC5B,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAEvB,CAAC;gBAEF,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,SAAS,CAClC,IAAI,CAAC,YAAY,EACjB;oBACE,IAAI,EAAE,cAAQ,CAAC,MAAM;oBACrB,UAAU,EAAE;wBACV,SAAS,EAAE,QAAQ;qBACpB;iBACF,EACD,aAAa,CAAC,OAAO,CAAC,MAAM,EAAE,CAC/B,CAAC;gBAEF,OAAO,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,EAAE,GAAG,EAAE;oBACxG,MAAM,eAAe,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAgB,CAAiB,CAAC;oBAE/E,eAAe;yBACZ,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;wBACf,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;wBACjC,IAAI,KAAK,CAAC,OAAO,EAAE;4BACjB,IAAI,CAAC,YAAY,CAAC,yCAAkB,CAAC,iBAAiB,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;yBACxE;wBACD,IAAI,KAAK,CAAC,KAAK,EAAE;4BACf,IAAI,CAAC,YAAY,CAAC,yCAAkB,CAAC,oBAAoB,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;yBACzE;oBACH,CAAC,CAAC;yBACD,OAAO,CAAC,GAAG,EAAE;wBACZ,IAAI,CAAC,GAAG,EAAE,CAAC;oBACb,CAAC,CAAC,CAAC;oBAEL,OAAO,eAAe,CAAC;gBACzB,CAAC,CAAC,CAAC;YACL,CAAC,CAAC;QACJ,CAAC,CAAC;IACJ,CAAC;CACF;AAtED,kEAsEC","sourcesContent":["import opentelemetry, { SpanKind } from \"@opentelemetry/api\";\nimport {\n  InstrumentationBase,\n  InstrumentationConfig,\n  InstrumentationNodeModuleDefinition,\n  isWrapped,\n} from \"@opentelemetry/instrumentation\";\nimport { SemanticAttributes } from \"@opentelemetry/semantic-conventions\";\n\nimport type * as prismaClient from \"@prisma/client\";\n\nimport { VERSION } from \"./version\";\n\nexport class PrismaClientInstrumentation extends InstrumentationBase {\n  constructor(config: InstrumentationConfig = {}) {\n    super(\"PrismaClientInstrumentation\", VERSION, config);\n  }\n\n  protected init() {\n    const prismaClientModule = new InstrumentationNodeModuleDefinition<typeof prismaClient>(\n      \"@prisma/client\",\n      [\"*\"],\n      (moduleExports: typeof prismaClient) => {\n        const PrismaClient = moduleExports.PrismaClient.prototype as any;\n\n        // _request\n        if (isWrapped(PrismaClient[\"_request\"])) {\n          this._unwrap(PrismaClient, \"_request\");\n        }\n        this._wrap(PrismaClient, \"_request\", this._patchRequest());\n\n        return moduleExports;\n      },\n      (moduleExports: typeof prismaClient) => {\n        const PrismaClient = moduleExports.PrismaClient.prototype as any;\n        this._unwrap(PrismaClient, \"_request\");\n      }\n    );\n\n    return [prismaClientModule];\n  }\n\n  private _patchRequest() {\n    const plugin = this;\n    return function (original: () => any) {\n      return function patchedRequest(this: any) {\n        const args = arguments[0] as {\n          clientMethod: string;\n        };\n\n        const span = plugin.tracer.startSpan(\n          args.clientMethod,\n          {\n            kind: SpanKind.CLIENT,\n            attributes: {\n              component: \"prisma\",\n            },\n          },\n          opentelemetry.context.active()\n        );\n\n        return opentelemetry.context.with(opentelemetry.trace.setSpan(opentelemetry.context.active(), span), () => {\n          const promiseResponse = original.apply(this, arguments as any) as Promise<any>;\n\n          promiseResponse\n            .catch((error) => {\n              span.setAttribute(\"error\", true);\n              if (error.message) {\n                span.setAttribute(SemanticAttributes.EXCEPTION_MESSAGE, error.message);\n              }\n              if (error.stack) {\n                span.setAttribute(SemanticAttributes.EXCEPTION_STACKTRACE, error.stack);\n              }\n            })\n            .finally(() => {\n              span.end();\n            });\n\n          return promiseResponse;\n        });\n      };\n    };\n  }\n}\n"]}