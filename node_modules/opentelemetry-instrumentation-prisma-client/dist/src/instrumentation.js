"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrismaClientInstrumentation = void 0;
const api_1 = __importStar(require("@opentelemetry/api"));
const instrumentation_1 = require("@opentelemetry/instrumentation");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const version_1 = require("./version");
class PrismaClientInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
        super("PrismaClientInstrumentation", version_1.VERSION, config);
    }
    init() {
        const prismaClientModule = new instrumentation_1.InstrumentationNodeModuleDefinition("@prisma/client", ["*"], (moduleExports) => {
            const PrismaClient = moduleExports.PrismaClient.prototype;
            // _request
            if ((0, instrumentation_1.isWrapped)(PrismaClient["_request"])) {
                this._unwrap(PrismaClient, "_request");
            }
            this._wrap(PrismaClient, "_request", this._patchRequest());
            return moduleExports;
        }, (moduleExports) => {
            const PrismaClient = moduleExports.PrismaClient.prototype;
            this._unwrap(PrismaClient, "_request");
        });
        return [prismaClientModule];
    }
    _patchRequest() {
        const plugin = this;
        return function (original) {
            return function patchedRequest() {
                const args = arguments[0];
                const span = plugin.tracer.startSpan(args.clientMethod, {
                    kind: api_1.SpanKind.CLIENT,
                    attributes: {
                        component: "prisma",
                    },
                }, api_1.default.context.active());
                return api_1.default.context.with(api_1.default.trace.setSpan(api_1.default.context.active(), span), () => {
                    const promiseResponse = original.apply(this, arguments);
                    promiseResponse
                        .catch((error) => {
                        span.setAttribute("error", true);
                        if (error.message) {
                            span.setAttribute(semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE, error.message);
                        }
                        if (error.stack) {
                            span.setAttribute(semantic_conventions_1.SemanticAttributes.EXCEPTION_STACKTRACE, error.stack);
                        }
                    })
                        .finally(() => {
                        span.end();
                    });
                    return promiseResponse;
                });
            };
        };
    }
}
exports.PrismaClientInstrumentation = PrismaClientInstrumentation;
//# sourceMappingURL=instrumentation.js.map