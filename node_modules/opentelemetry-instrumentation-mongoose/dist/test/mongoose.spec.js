"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const expect_1 = __importDefault(require("expect"));
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const src_1 = require("../src");
const contrib_test_utils_1 = require("@opentelemetry/contrib-test-utils");
const instrumentation = contrib_test_utils_1.registerInstrumentationTesting(new src_1.MongooseInstrumentation());
const mongoose_1 = __importDefault(require("mongoose"));
const user_1 = __importStar(require("./user"));
const asserts_1 = require("./asserts");
// Please run mongodb in the background: docker run -d -p 27017:27017 -v ~/data:/data/db mongo
describe('mongoose instrumentation', () => {
    before(async () => {
        await mongoose_1.default.connect('mongodb://localhost:27017', {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            useFindAndModify: false,
            useCreateIndex: true,
        });
    });
    after(async () => {
        await mongoose_1.default.connection.close();
    });
    beforeEach(async () => {
        instrumentation.disable();
        instrumentation.setConfig({
            dbStatementSerializer: (_operation, payload) => JSON.stringify(payload),
        });
        instrumentation.enable();
        await user_1.loadUsers();
        await user_1.default.createIndexes();
    });
    afterEach(async () => {
        instrumentation.disable();
        await user_1.default.collection.drop().catch();
    });
    it('instrumenting save operation with promise', async () => {
        const document = {
            firstName: 'Test first name',
            lastName: 'Test last name',
            email: 'test@example.com',
        };
        const user = new user_1.default(document);
        await user.save();
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('save');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.document).toEqual(expect_1.default.objectContaining(document));
    });
    it('instrumenting save operation with callback', (done) => {
        const document = {
            firstName: 'Test first name',
            lastName: 'Test last name',
            email: 'test@example.com',
        };
        const user = new user_1.default(document);
        user.save(function () {
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('save');
            const statement = asserts_1.getStatement(spans[0]);
            expect_1.default(statement.document).toEqual(expect_1.default.objectContaining(document));
            done();
        });
    });
    it('instrumenting find operation', async () => {
        await user_1.default.find({ id: '_test' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('find');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.condition).toEqual({ id: '_test' });
    });
    it('instrumenting multiple find operations', async () => {
        await Promise.all([user_1.default.find({ id: '_test1' }), user_1.default.find({ id: '_test2' })]);
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(2);
        asserts_1.assertSpan(spans[0]);
        asserts_1.assertSpan(spans[1]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('find');
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toMatch(/.*{"id":"_test[1-2]"}.*/g);
        expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('find');
        expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toMatch(/.*{"id":"_test[1-2]"}.*/g);
    });
    it('instrumenting find operation with chaining structures', async () => {
        await user_1.default.find({ id: '_test' }).skip(1).limit(2).sort({ email: 'asc' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('find');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.condition).toEqual({ id: '_test' });
        expect_1.default(statement.options).toEqual({ skip: 1, limit: 2, sort: { email: 1 } });
    });
    it('instrumenting remove operation [deprecated]', async () => {
        const user = await user_1.default.findOne({ email: 'john.doe@example.com' });
        await user.remove();
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(2);
        asserts_1.assertSpan(spans[1]);
        expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('remove');
    });
    it('instrumenting remove operation with callbacks [deprecated]', (done) => {
        user_1.default.findOne({ email: 'john.doe@example.com' }).then((user) => user.remove({ overwrite: true }, () => {
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(2);
            asserts_1.assertSpan(spans[1]);
            expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('remove');
            expect_1.default(asserts_1.getStatement(spans[1]).options).toEqual({ overwrite: true });
            done();
        }));
    });
    it('instrumenting deleteOne operation', async () => {
        await user_1.default.deleteOne({ email: 'john.doe@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('deleteOne');
    });
    it('instrumenting updateOne operation on models', async () => {
        const user = await user_1.default.findOne({ email: 'john.doe@example.com' });
        await user.updateOne({ $inc: { age: 1 } }, { skip: 0 });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(2);
        asserts_1.assertSpan(spans[1]);
        expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('updateOne');
        const statement = asserts_1.getStatement(spans[1]);
        expect_1.default(statement.options).toEqual({ skip: 0 });
        expect_1.default(statement.updates).toEqual({ $inc: { age: 1 } });
        expect_1.default(statement.condition._id).toBeDefined();
    });
    it('instrumenting updateOne operation', async () => {
        await user_1.default.updateOne({ email: 'john.doe@example.com' }, { $inc: { age: 1 } }, { skip: 0 });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('updateOne');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({ skip: 0 });
        expect_1.default(statement.updates).toEqual({ $inc: { age: 1 } });
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
    });
    it('instrumenting count operation [deprecated]', async () => {
        await user_1.default.count({});
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('count');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({});
    });
    it('instrumenting countDocuments operation', async () => {
        await user_1.default.countDocuments({ email: 'john.doe@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('countDocuments');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
    });
    it('instrumenting estimatedDocumentCount operation', async () => {
        await user_1.default.estimatedDocumentCount();
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('estimatedDocumentCount');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({});
    });
    it('instrumenting deleteMany operation', async () => {
        await user_1.default.deleteMany();
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('deleteMany');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({});
    });
    it('instrumenting findOne operation', async () => {
        await user_1.default.findOne({ email: 'john.doe@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('findOne');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
    });
    it('instrumenting update operation [deprecated]', async () => {
        await user_1.default.update({ email: 'john.doe@example.com' }, { email: 'john.doe2@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('update');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
        expect_1.default(statement.updates).toEqual({ email: 'john.doe2@example.com' });
    });
    it('instrumenting updateOne operation', async () => {
        await user_1.default.updateOne({ email: 'john.doe@example.com' }, { age: 55 });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('updateOne');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
        expect_1.default(statement.updates).toEqual({ age: 55 });
    });
    it('instrumenting updateMany operation', async () => {
        await user_1.default.updateMany({ age: 18 }, { isDeleted: true });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('updateMany');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ age: 18 });
        expect_1.default(statement.updates).toEqual({ isDeleted: true });
    });
    it('instrumenting findOneAndDelete operation', async () => {
        await user_1.default.findOneAndDelete({ email: 'john.doe@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('findOneAndDelete');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
    });
    it('instrumenting findOneAndUpdate operation', async () => {
        await user_1.default.findOneAndUpdate({ email: 'john.doe@example.com' }, { isUpdated: true });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(2);
        asserts_1.assertSpan(spans[0]);
        asserts_1.assertSpan(spans[1]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('findOne');
        expect_1.default(spans[1].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('findOneAndUpdate');
        const statement = asserts_1.getStatement(spans[1]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
        expect_1.default(statement.updates).toEqual({ isUpdated: true });
    });
    it('instrumenting findOneAndRemove operation', async () => {
        await user_1.default.findOneAndRemove({ email: 'john.doe@example.com' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('findOneAndRemove');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.condition).toEqual({ email: 'john.doe@example.com' });
    });
    it('instrumenting create operation', async () => {
        const document = { firstName: 'John', lastName: 'Doe', email: 'john.doe+1@example.com' };
        await user_1.default.create(document);
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('save');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.options).toEqual({});
        expect_1.default(statement.document).toEqual(expect_1.default.objectContaining(document));
    });
    it('instrumenting aggregate operation', async () => {
        await user_1.default.aggregate([
            { $match: { firstName: 'John' } },
            { $group: { _id: 'John', total: { $sum: '$amount' } } },
        ]);
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('aggregate');
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.aggregatePipeline).toEqual([
            { $match: { firstName: 'John' } },
            { $group: { _id: 'John', total: { $sum: '$amount' } } },
        ]);
    });
    it('instrumenting aggregate operation with callback', (done) => {
        user_1.default.aggregate([{ $match: { firstName: 'John' } }, { $group: { _id: 'John', total: { $sum: '$amount' } } }], () => {
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('aggregate');
            const statement = asserts_1.getStatement(spans[0]);
            expect_1.default(statement.aggregatePipeline).toEqual([
                { $match: { firstName: 'John' } },
                { $group: { _id: 'John', total: { $sum: '$amount' } } },
            ]);
            done();
        });
    });
    it('instrumenting combined operation with async/await', async () => {
        await user_1.default.find({ id: '_test' }).skip(1).limit(2).sort({ email: 'asc' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        const statement = asserts_1.getStatement(spans[0]);
        expect_1.default(statement.condition).toEqual({ id: '_test' });
        expect_1.default(statement.options).toEqual({ skip: 1, limit: 2, sort: { email: 1 } });
    });
    it('empty dbStatementSerializer does not create a statement attribute', async () => {
        instrumentation.disable();
        instrumentation.setConfig({ dbStatementSerializer: undefined });
        instrumentation.enable();
        await user_1.default.find({ id: '_test' });
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        expect_1.default(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe(undefined);
    });
    it('projection is sent to serializer', async () => {
        instrumentation.disable();
        instrumentation.setConfig({ dbStatementSerializer: (_operation, payload) => JSON.stringify(payload) });
        instrumentation.enable();
        const projection = { firstName: 1 };
        await user_1.default.find({ id: '_test1' }, projection);
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        asserts_1.assertSpan(spans[0]);
        const reqPayload = JSON.parse(spans[0].attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]);
        expect_1.default(reqPayload.fields).toStrictEqual(projection);
    });
    describe('responseHook', () => {
        const RESPONSE = 'db.response';
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                responseHook: (span, response) => span.setAttribute(RESPONSE, JSON.stringify(response)),
            });
            instrumentation.enable();
        });
        it('responseHook works with async/await in exec patch', async () => {
            await user_1.default.deleteOne({ email: 'john.doe@example.com' });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(JSON.parse(spans[0].attributes[RESPONSE])).toEqual({ n: 1, ok: 1, deletedCount: 1 });
        });
        it('responseHook works with callback in exec patch', (done) => {
            user_1.default.deleteOne({ email: 'john.doe@example.com' }, { lean: 1 }, () => {
                const spans = contrib_test_utils_1.getTestSpans();
                expect_1.default(spans.length).toBe(1);
                asserts_1.assertSpan(spans[0]);
                expect_1.default(JSON.parse(spans[0].attributes[RESPONSE])).toEqual({
                    n: 1,
                    ok: 1,
                    deletedCount: 1,
                });
                done();
            });
        });
        it('responseHook works with async/await in model methods patch', async () => {
            const document = {
                firstName: 'Test first name',
                lastName: 'Test last name',
                email: 'test@example.com',
            };
            const user = new user_1.default(document);
            const createdUser = await user.save();
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[RESPONSE]).toEqual(JSON.stringify(createdUser));
        });
        it('responseHook works with callback in model methods patch', (done) => {
            const document = {
                firstName: 'Test first name',
                lastName: 'Test last name',
                email: 'test@example.com',
            };
            const user = new user_1.default(document);
            user.save((_err, createdUser) => {
                const spans = contrib_test_utils_1.getTestSpans();
                expect_1.default(spans.length).toBe(1);
                asserts_1.assertSpan(spans[0]);
                expect_1.default(spans[0].attributes[RESPONSE]).toEqual(JSON.stringify(createdUser));
                done();
            });
        });
        it('responseHook works with async/await in aggregate patch', async () => {
            await user_1.default.aggregate([
                { $match: { firstName: 'John' } },
                { $group: { _id: 'John', total: { $sum: '$amount' } } },
            ]);
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(JSON.parse(spans[0].attributes[RESPONSE])).toEqual([{ _id: 'John', total: 0 }]);
        });
        it('responseHook works with callback in aggregate patch', (done) => {
            user_1.default.aggregate([{ $match: { firstName: 'John' } }, { $group: { _id: 'John', total: { $sum: '$amount' } } }], () => {
                const spans = contrib_test_utils_1.getTestSpans();
                expect_1.default(spans.length).toBe(1);
                asserts_1.assertSpan(spans[0]);
                expect_1.default(JSON.parse(spans[0].attributes[RESPONSE])).toEqual([{ _id: 'John', total: 0 }]);
                done();
            });
        });
        it('error in response hook does not fail anything', async () => {
            instrumentation.disable();
            instrumentation.setConfig({
                responseHook: () => {
                    throw new Error('some error');
                },
            });
            instrumentation.enable();
            await user_1.default.deleteOne({ email: 'john.doe@example.com' });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[RESPONSE]).toBe(undefined);
        });
    });
    describe('moduleVersionAttributeName config', () => {
        const VERSION_ATTR = 'module.version';
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                moduleVersionAttributeName: VERSION_ATTR,
            });
            instrumentation.enable();
        });
        it('moduleVersionAttributeName works with exec patch', async () => {
            await user_1.default.deleteOne({ email: 'john.doe@example.com' });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[VERSION_ATTR]).toMatch(/\d{1,4}\.\d{1,4}\.\d{1,5}.*/);
        });
        it('moduleVersionAttributeName with model methods patch', async () => {
            const document = {
                firstName: 'Test first name',
                lastName: 'Test last name',
                email: 'test@example.com',
            };
            const user = new user_1.default(document);
            await user.save();
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[VERSION_ATTR]).toMatch(/\d{1,4}\.\d{1,4}\.\d{1,5}.*/);
        });
        it('moduleVersionAttributeName works with aggregate patch', async () => {
            await user_1.default.aggregate([
                { $match: { firstName: 'John' } },
                { $group: { _id: 'John', total: { $sum: '$amount' } } },
            ]);
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(1);
            asserts_1.assertSpan(spans[0]);
            expect_1.default(spans[0].attributes[VERSION_ATTR]).toMatch(/\d{1,4}\.\d{1,4}\.\d{1,5}.*/);
        });
    });
    describe('requireParentSpan', () => {
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                requireParentSpan: true,
            });
            instrumentation.enable();
        });
        it('should not start span on mongoose method', async () => {
            await api_1.context.with(api_1.ROOT_CONTEXT, async () => {
                const user = new user_1.default({
                    firstName: 'Test first name',
                    lastName: 'Test last name',
                    email: 'test@example.com',
                });
                await user.save();
            });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(0);
        });
        it('should not start span on find', async () => {
            await api_1.context.with(api_1.ROOT_CONTEXT, async () => {
                await user_1.default.find({ id: '_test' });
            });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(0);
        });
        it('should not start span on aggregate', async () => {
            await api_1.context.with(api_1.ROOT_CONTEXT, async () => {
                await user_1.default.aggregate([
                    { $match: { firstName: 'John' } },
                    { $group: { _id: 'John', total: { $sum: '$amount' } } },
                ]);
            });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(0);
        });
    });
});
//# sourceMappingURL=mongoose.spec.js.map