# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Auth {
  """JWT access token payload"""
  accessTokenPayload: String!
  firstname: String
  lastname: String
  permissions: String

  """JWT refresh token payload"""
  refreshTokenPayload: String!
  userId: ID!
}

type AuthMutations {
  login(data: LoginInput!): Auth!
  register(data: SignupInput!): Boolean!
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input CreatePostInput {
  """Example field (placeholder)"""
  exampleField: Int!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Group {
  createdAt: DateTime!
  createdByName: String
  createdByUsername: String
  description: String
  group: String!
  id: ID!
  name: String!
  status: String!
  updatedAt: DateTime
}

input GroupCreateInput {
  createdAt: DateTime
  createdByName: String
  description: String
  group: String
  name: String
  status: String
  updatedAt: DateTime
}

type GroupMutations {
  createGroup(data: GroupCreateInput!): Group!
  removeGroup(where: GroupWhereUniqueInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group!
}

input GroupOrderByWithRelationInput {
  createdAt: SortOrder
  createdByName: SortOrder
  description: SortOrder
  group: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
}

enum GroupScalarFieldEnum {
  createdAt
  createdById
  createdByName
  createdByUsername
  description
  domainId
  group
  id
  name
  status
  updatedAt
}

input GroupUpdateInput {
  createdAt: DateTime
  createdByName: String
  description: String
  group: String
  name: String
  status: String
  updatedAt: DateTime
}

input GroupWhereInput {
  AND: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  createdAt: DateTimeFilter
  createdByName: StringNullableFilter
  description: StringNullableFilter
  group: StringFilter
  id: IntFilter
  name: StringFilter
  status: StringFilter
  updatedAt: DateTimeNullableFilter
}

input GroupWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonNullableFilter {
  equals: JSON
  not: JSON
}

input LoginInput {
  email: String!
  password: String!
}

type Mutation {
  auth: AuthMutations
  group: GroupMutations
  policy: PolicyMutations
  post: PostMutations
  problem: ProblemMutations
  role: RoleMutations
  user: UserMutations
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Policy {
  action: String!
  condition: String
  createdAt: DateTime!
  createdByName: String
  createdByUsername: String
  effect: String!
  effectWith: String!
  id: ID!
  object: String!
  subject: String!
  updatedAt: DateTime
}

input PolicyCreateInput {
  action: String
  condition: String
  createdAt: DateTime
  createdByName: String
  effect: String
  effectWith: String
  object: String
  subject: String
  updatedAt: DateTime
}

input PolicyFindByRoleResourceInput {
  resource: String
  roleId: String
}

type PolicyMutations {
  createCasbinPolicies(data: [PolicyCreateInput!]!): Boolean!
  createPolicy(data: PolicyCreateInput!): Boolean!
  removePolicy(where: PolicyWhereUniqueInput!): Policy!
  updatePolicy(data: PolicyUpdateInput!, where: PolicyWhereUniqueInput!): Policy!
}

input PolicyOrderByWithRelationInput {
  action: SortOrder
  condition: SortOrder
  createdAt: SortOrder
  createdByName: SortOrder
  effect: SortOrder
  effectWith: SortOrder
  id: SortOrder
  object: SortOrder
  subject: SortOrder
  updatedAt: SortOrder
}

enum PolicyScalarFieldEnum {
  action
  condition
  createdAt
  createdById
  createdByName
  createdByUsername
  domainId
  effect
  effectWith
  id
  object
  ptype
  subject
  updatedAt
}

input PolicyUpdateInput {
  action: String
  condition: String
  createdAt: DateTime
  createdByName: String
  effect: String
  effectWith: String
  object: String
  subject: String
  updatedAt: DateTime
}

input PolicyWhereInput {
  AND: [PolicyWhereInput!]
  NOT: [PolicyWhereInput!]
  OR: [PolicyWhereInput!]
  action: StringFilter
  condition: StringNullableFilter
  createdAt: DateTimeFilter
  createdByName: StringNullableFilter
  effect: StringFilter
  effectWith: StringFilter
  id: IntFilter
  object: StringFilter
  subject: StringFilter
  updatedAt: DateTimeNullableFilter
}

input PolicyWhereUniqueInput {
  id: Int
}

type Post {
  authorId: Int
  content: String
  domainId: Int!
  id: ID!
  published: Boolean
  title: String!
}

type PostMutations {
  createPost(createPostInput: CreatePostInput!): Post!
  removePost(id: Int!): Post!
  updatePost(updatePostInput: UpdatePostInput!): Post!
}

input PostOrderByWithRelationInput {
  authorId: SortOrder
  content: SortOrder
  domainId: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  domainId
  id
  published
  title
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  authorId: IntNullableFilter
  content: StringNullableFilter
  domainId: IntFilter
  id: IntFilter
  published: BoolNullableFilter
  title: StringFilter
}

input PostWhereUniqueInput {
  id: Int
}

type Problem {
  acceptLanguage: [Int!]
  acceptRate: Float
  category: String
  codeSnippets: JSON
  commentCount: Int
  companyTags: [Int!]
  contestId: Int
  contributors: [JSON!]
  createdAt: DateTime!
  createdByName: String
  createdByUsername: String
  description: String
  difficulty: String!
  dislikes: Int!
  exampleTestcases: JSON
  examples: JSON
  highlightSolutionCount: Int
  hint: JSON
  id: ID!
  inputType: String
  isFavorited: Boolean!
  likes: Int!
  name: String!
  officalSolutionCount: Int
  outputType: String
  slug: String
  solutions: JSON
  status: String!
  topicTags: [Int!]
  updatedAt: DateTime
}

input ProblemCreateInput {
  acceptLanguage: ProblemCreateacceptLanguageInput
  acceptRate: Float
  category: String
  codeSnippets: JSON
  companyTags: ProblemCreatecompanyTagsInput
  contestId: Int
  contributors: ProblemCreatecontributorsInput
  createdAt: DateTime
  createdByName: String
  description: String
  difficulty: String
  dislikes: Int
  exampleTestcases: JSON
  examples: JSON
  highlightSolutionCount: Int
  hint: JSON
  inputType: String
  isFavorited: Boolean
  likes: Int
  name: String!
  officalSolutionCount: Int
  outputType: String
  solutions: JSON
  status: String
  topicTags: ProblemCreatetopicTagsInput
  updatedAt: DateTime
}

input ProblemCreateacceptLanguageInput {
  set: [Int!]!
}

input ProblemCreatecompanyTagsInput {
  set: [Int!]!
}

input ProblemCreatecontributorsInput {
  set: [JSON!]!
}

input ProblemCreatetopicTagsInput {
  set: [Int!]!
}

type ProblemMutations {
  createProblem(data: ProblemCreateInput!): Problem!
  removeProblem(id: Int!): Problem!
  updateProblem(updateProblemInput: UpdateProblemInput!): Problem!
}

type Query {
  group(where: GroupWhereUniqueInput!): Group!
  groups(cursor: GroupWhereUniqueInput, distinct: [GroupScalarFieldEnum!], orderBy: [GroupOrderByWithRelationInput!], skip: Int, take: Int, where: GroupWhereInput): [Group!]!
  policies(cursor: PolicyWhereUniqueInput, distinct: [PolicyScalarFieldEnum!], orderBy: [PolicyOrderByWithRelationInput!], skip: Int, take: Int, where: PolicyWhereInput): [Policy!]!
  policy(where: PolicyWhereUniqueInput!): Policy!
  post(where: PostWhereUniqueInput!): Post!
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  problem(id: Int!): Problem!
  problems: [Problem!]!
  role(where: RoleWhereUniqueInput!): Role!
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  z_checkValidPolicyCondition(data: String!): Boolean!
  z_policyByRoleResource(where: PolicyFindByRoleResourceInput!): [Policy!]!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  createdAt: DateTime!
  createdByName: String
  createdByUsername: String
  description: String
  id: ID!
  name: String!
  role: String!
  updatedAt: DateTime
}

input RoleCreateInput {
  createdAt: DateTime
  createdByName: String
  description: String
  name: String

  """Example field (placeholder)"""
  polices: [PolicyCreateInput!]!
  role: String
  updatedAt: DateTime
}

type RoleGroup {
  id: ID!
  ptype: String!
  role: String
  rule: String
}

input RoleGroupCreateInput {
  ptype: String
  role: String
  rule: String
}

input RoleGroupUpdateInput {
  ptype: String
  role: String
  rule: String
}

input RoleGroupWhereUniqueInput {
  id: Int
}

type RoleMutations {
  createRole(data: RoleCreateInput!): Role!
  createRoleGroup(data: RoleGroupCreateInput!): Boolean!
  removeRole(where: RoleWhereUniqueInput!): Role!
  removeRoleGroup(id: Int!): RoleGroup!
  updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  updateRoleGroup(data: RoleGroupUpdateInput!, where: RoleGroupWhereUniqueInput!): RoleGroup!
}

input RoleOrderByWithRelationInput {
  createdAt: SortOrder
  createdByName: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  createdById
  createdByName
  createdByUsername
  description
  domainId
  id
  name
  role
  updatedAt
}

input RoleUpdateInput {
  createdAt: DateTime
  createdByName: String
  description: String
  name: String
  role: String
  updatedAt: DateTime
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  createdAt: DateTimeFilter
  createdByName: StringNullableFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  role: StringFilter
  updatedAt: DateTimeNullableFilter
}

input RoleWhereUniqueInput {
  id: Int
}

input SignupInput {
  email: String!
  firstname: String
  lastname: String
  password: String!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input UpdatePostInput {
  """Example field (placeholder)"""
  exampleField: Int
  id: Int!
}

input UpdateProblemInput {
  """Example field (placeholder)"""
  exampleField: Int
  id: Int!
}

type User {
  createdAt: DateTime!
  createdByName: String
  createdByUsername: String
  email: String!
  extendData: JSON
  firstname: String!
  id: ID!
  lastname: String!
  role: String!
  status: String!
  updatedAt: DateTime
  username: String!
}

input UserCreateInput {
  createdAt: DateTime
  createdByName: String
  email: String!
  extendData: JSON
  firstname: String
  lastname: String
  password: String
  role: String
  status: String
  updatedAt: DateTime
  username: String
}

type UserMutations {
  createUser(data: UserCreateInput!): User!
  removeUser(id: Int!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  createdByName: SortOrder
  email: SortOrder
  extendData: SortOrder
  firstname: SortOrder
  id: SortOrder
  lastname: SortOrder
  password: SortOrder
  role: SortOrder
  status: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

enum UserScalarFieldEnum {
  createdAt
  createdById
  createdByName
  createdByUsername
  domainId
  email
  extendData
  firstname
  id
  lastname
  password
  role
  status
  updatedAt
  username
}

input UserUpdateInput {
  createdAt: DateTime
  createdByName: String
  email: String
  extendData: JSON
  firstname: String
  lastname: String
  password: String
  role: String
  status: String
  updatedAt: DateTime
  username: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  createdByName: StringNullableFilter
  email: StringFilter
  extendData: JsonNullableFilter
  firstname: StringFilter
  id: IntFilter
  lastname: StringFilter
  password: StringFilter
  role: StringFilter
  status: StringFilter
  updatedAt: DateTimeNullableFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
