{"version":3,"file":"plugins.cjs.development.js","sources":["../src/select.ts","../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/delete.ts","../src/sdlInputs.ts"],"sourcesContent":["import { GraphQLResolveInfo } from 'graphql';\nimport { DMMF } from '@prisma/client/runtime';\n// @ts-ignore\nimport graphqlFields from 'graphql-fields';\n\n/**\n * Convert `info` to select object accepted by `prisma client`.\n * @param info - GraphQLResolveInfo.\n * @example\n * // Graphql query\n * {\n *    findManyUser{\n *      id\n *      posts(where: { title: { contains: \"a\" } }, first: 10) {\n *        id\n *        comments{\n *          id\n *        }\n *      }\n *    }\n * }\n * // convert to\n * {\n *  select: {\n *    id: true,\n *    posts: {\n *      select: { id: true, comments: { select: { id: true } } },\n *      where: { title: { contains: \"a\" } },\n *      first: 10\n *    }\n *  }\n * }\n *\n * // Use\n *\n * const select = new PrismaSelect(info);\n *\n * prisma.user.findMany({\n *  ...args,\n *  ...select.value,\n * })\n *\n **/\nexport class PrismaSelect {\n  private availableArgs = ['where', 'orderBy', 'skip', 'cursor', 'take'];\n  private allowedProps = ['_count'];\n  private isAggregate: boolean = false;\n\n  constructor(\n    private info: GraphQLResolveInfo,\n    private options?: {\n      defaultFields?: {\n        [key: string]:\n          | { [key: string]: boolean }\n          | ((select: any) => { [key: string]: boolean });\n      };\n      dmmf?: DMMF.Document[];\n    },\n  ) {}\n\n  get value() {\n    const returnType = this.info.returnType\n      .toString()\n      .replace(/]/g, '')\n      .replace(/\\[/g, '')\n      .replace(/!/g, '');\n    this.isAggregate = returnType.includes('Aggregate');\n    return this.valueWithFilter(returnType);\n  }\n\n  get dataModel() {\n    const models: DMMF.Model[] = [];\n    if (this.options?.dmmf) {\n      this.options?.dmmf.forEach((doc) => {\n        models.push(...doc.datamodel.models);\n      });\n    } else {\n      const { Prisma } = require('@prisma/client');\n      if (Prisma.dmmf && Prisma.dmmf.datamodel) {\n        models.push(...Prisma.dmmf.datamodel.models);\n      }\n    }\n    return models;\n  }\n\n  get defaultFields() {\n    return this.options?.defaultFields;\n  }\n\n  private get fields() {\n    return graphqlFields(\n      this.info,\n      {},\n      {\n        excludedFields: ['__typename'],\n        processArguments: true,\n      },\n    );\n  }\n\n  private static getModelMap(docs?: string, name?: string) {\n    const value = docs?.match(/@PrismaSelect.map\\(\\[(.*?)\\]\\)/);\n    if (value && name) {\n      const asArray = value[1]\n        .replace(/ /g, '')\n        .split(',')\n        .filter((v) => v);\n      return asArray.includes(name);\n    }\n    return false;\n  }\n\n  private model(name?: string) {\n    return this.dataModel.find(\n      (item) =>\n        item.name === name ||\n        PrismaSelect.getModelMap(item.documentation, name),\n    );\n  }\n\n  private field(name: string, model?: DMMF.Model) {\n    return model?.fields.find((item) => item.name === name);\n  }\n\n  static isObject(item: any) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n  }\n\n  static mergeDeep(target: any, ...sources: any[]): any {\n    if (!sources.length) return target;\n    const source: any = sources.shift();\n\n    if (PrismaSelect.isObject(target) && PrismaSelect.isObject(source)) {\n      for (const key in source) {\n        if (PrismaSelect.isObject(source[key])) {\n          if (!target[key]) Object.assign(target, { [key]: {} });\n          PrismaSelect.mergeDeep(target[key], source[key]);\n        } else {\n          Object.assign(target, { [key]: source[key] });\n        }\n      }\n    }\n\n    return PrismaSelect.mergeDeep(target, ...sources);\n  }\n\n  /**\n   * Get nested value from select object.\n   * @param field - name of field in select object.\n   * @param filterBy - Model name as you have in schema.prisma file.\n   * @param mergeObject\n   * @example\n   * // Graphql query\n   * {\n   *    findManyUser{\n   *      id\n   *      posts{\n   *        id\n   *        comments{\n   *          id\n   *        }\n   *      }\n   *    }\n   * }\n   *\n   * // when you need to get more nested fields just add `.`\n   * PrismaSelect.valueOf('posts.comments', 'Comment');\n   * // return\n   * { select: { id: true } }\n   *\n   * PrismaSelect.valueOf('posts', 'Post');\n   *\n   * // return\n   * { select: { id: true, comments: { select: { id: true } } } }\n   *\n   **/\n  valueOf(field: string, filterBy?: string, mergeObject: any = {}) {\n    const splitItem = field.split('.');\n    let newValue = this.getSelect(this.fields);\n    for (const field of splitItem) {\n      if (this.isAggregate && newValue.hasOwnProperty(field)) {\n        newValue = newValue[field];\n      } else if (\n        !this.isAggregate &&\n        newValue.hasOwnProperty('select') &&\n        newValue.select.hasOwnProperty(field)\n      ) {\n        newValue = newValue.select[field];\n      } else {\n        return {};\n      }\n    }\n    return filterBy\n      ? PrismaSelect.mergeDeep(this.filterBy(filterBy, newValue), mergeObject)\n      : newValue;\n  }\n\n  /**\n   * Work with this method if your GraphQL type name not like Schema model name.\n   * @param modelName - Model name as you have in schema.prisma file.\n   * @example\n   * // normal call\n   * const select = new PrismaSelect(info).value\n   *\n   * // With filter will filter select object with provided schema model name\n   * const select = new PrismaSelect(info).valueWithFilter('User');\n   *\n   **/\n  valueWithFilter(modelName: string) {\n    return this.filterBy(modelName, this.getSelect(this.fields));\n  }\n\n  private filterBy(modelName: string, selectObject: any) {\n    const model = this.model(modelName);\n    if (model && typeof selectObject === 'object') {\n      let defaultFields = {};\n      if (this.defaultFields && this.defaultFields[modelName]) {\n        const modelFields = this.defaultFields[modelName];\n        defaultFields =\n          typeof modelFields === 'function'\n            ? modelFields(selectObject.select)\n            : modelFields;\n      }\n      const filteredObject = {\n        ...selectObject,\n        select: { ...defaultFields },\n      };\n      Object.keys(selectObject.select).forEach((key) => {\n        if (this.allowedProps.includes(key)) {\n          filteredObject.select[key] = selectObject.select[key];\n        } else {\n          const field = this.field(key, model);\n          if (field) {\n            if (field.kind !== 'object') {\n              filteredObject.select[key] = true;\n            } else {\n              const subModelFilter = this.filterBy(\n                field.type.toString(),\n                selectObject.select[key],\n              );\n              if (Object.keys(subModelFilter.select).length > 0) {\n                filteredObject.select[key] = subModelFilter;\n              }\n            }\n          }\n        }\n      });\n      return filteredObject;\n    } else {\n      return selectObject;\n    }\n  }\n\n  private getSelect(fields: any) {\n    const selectObject: any = this.isAggregate ? {} : { select: {} };\n    Object.keys(fields).forEach((key) => {\n      if (Object.keys(fields[key]).length === 0) {\n        if (this.isAggregate) {\n          selectObject[key] = true;\n        } else {\n          selectObject.select[key] = true;\n        }\n      } else if (key === '__arguments') {\n        fields[key].forEach((arg: any) => {\n          Object.keys(arg).forEach((key2) => {\n            if (this.availableArgs.includes(key2)) {\n              selectObject[key2] = arg[key2].value;\n            }\n          });\n        });\n      } else {\n        if (this.isAggregate) {\n          selectObject[key] = this.getSelect(fields[key]);\n        } else {\n          selectObject.select[key] = this.getSelect(fields[key]);\n        }\n      }\n    });\n    return selectObject;\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { DMMF } from '@prisma/client/runtime';\n\ninterface DeleteData {\n  name: string;\n  where: object;\n}\n\nexport interface onDeleteArgs {\n  model: string;\n  where?: any;\n  deleteParent?: boolean;\n}\n\ninterface BatchPayload {\n  count: number;\n}\n\n/**\n * Handle all relation onDelete type\n * @param prisma - optional arg you can send your client class.\n * @param options - optional arg you can send your custom options { dmmf?: DMMF.Document }.\n * @example\n * const prisma = new PrismaClient({log: ['query']});\n * const prismaDelete = new PrismaDelete(prisma);\n *\n * // or new PrismaDelete(); we will create new client and use\n *\n * // use onDelete method\n * prismaDelete.onDelete({\n *  model: 'User',\n *  where: { id: 1 },\n *  deleteParent: true // if true will also delete user record default false\n * });\n *\n **/\nexport class PrismaDelete {\n  constructor(\n    private prisma: any,\n    private options?: { dmmf?: DMMF.Document },\n  ) {}\n\n  get getDMMF(): DMMF.Document {\n    const { Prisma } = require('@prisma/client');\n    return Prisma.dmmf;\n  }\n\n  get dataModel() {\n    if (this.options?.dmmf) {\n      return this.options?.dmmf?.datamodel;\n    } else {\n      return this.getDMMF?.datamodel;\n    }\n  }\n\n  private getModel(modelName: string) {\n    return this.dataModel?.models.find((item) => item.name === modelName);\n  }\n\n  private static getModelName(modelName: string) {\n    return modelName.charAt(0).toLowerCase() + modelName.slice(1);\n  }\n\n  private getFieldByType(modelName: string, fieldType: string) {\n    return this.getModel(modelName)?.fields.find(\n      (item) => item.type === fieldType && !item.isList,\n    );\n  }\n\n  private getModelIdFieldName(modelName: string) {\n    return this.getModel(modelName)?.fields.find((item) => item.isId)?.name;\n  }\n\n  private getOnDeleteFields(modelName: string, type: 'SET_NULL' | 'CASCADE') {\n    return this.getModel(modelName)?.fields.filter(\n      (item) =>\n        item.documentation?.includes('@onDelete') &&\n        item.documentation?.includes(type),\n    );\n  }\n\n  private async setFieldNull(modelName: string, field: DMMF.Field, where: any) {\n    const name = PrismaDelete.getModelName(modelName);\n    const modelId = this.getModelIdFieldName(modelName);\n    const fieldModelId = this.getModelIdFieldName(field.type.toString());\n    if (modelId && fieldModelId && !field.isRequired) {\n      const fieldSelect = field.isList\n        ? { [field.name]: { select: { [fieldModelId]: true } } }\n        : {};\n      const results = await this.prisma[name].findMany({\n        where,\n        select: {\n          [modelId]: true,\n          ...fieldSelect,\n        },\n      });\n      for (const result of results) {\n        if (!(field.isList && result[field.name].length === 0)) {\n          await this.prisma[name].update({\n            where: {\n              [modelId]: result[modelId],\n            },\n            data: {\n              [field.name]: {\n                disconnect: field.isList ? result[field.name] : true,\n              },\n            },\n          });\n        }\n      }\n    }\n  }\n\n  private async getDeleteArray(\n    modelName: string,\n    whereInput: any,\n    includeParent = true,\n  ) {\n    const deleteArray: DeleteData[] = includeParent\n      ? [\n          {\n            name: PrismaDelete.getModelName(modelName),\n            where: whereInput,\n          },\n        ]\n      : [];\n\n    const nullFields = this.getOnDeleteFields(modelName, 'SET_NULL');\n    if (nullFields) {\n      for (const nullField of nullFields) {\n        await this.setFieldNull(modelName, nullField, whereInput);\n      }\n    }\n\n    const cascadeFields = this.getOnDeleteFields(modelName, 'CASCADE');\n    if (cascadeFields) {\n      for (const cascadeField of cascadeFields) {\n        const childField = this.getFieldByType(\n          cascadeField.type.toString(),\n          modelName,\n        );\n        if (childField) {\n          if (cascadeField.type !== modelName) {\n            deleteArray.push(\n              ...(await this.getDeleteArray(cascadeField.type.toString(), {\n                [childField.name]: whereInput,\n              })),\n            );\n          } else {\n            deleteArray.push({\n              name: PrismaDelete.getModelName(modelName),\n              where: {\n                [childField.name]: whereInput,\n              },\n            });\n          }\n        }\n      }\n    }\n\n    return deleteArray;\n  }\n  /**\n   * Handle all relation onDelete type\n   * @param onDeleteArgs - Object with model data.\n   * @return count of deleted records if deleteParent is true\n   * @example\n   * const prismaDelete = new PrismaDelete();\n   * prismaDelete.onDelete({\n   *  model: 'User',\n   *  where: { id: 1 },\n   *  deleteParent: true // if true will also delete user record default false\n   * });\n   *\n   **/\n  async onDelete({\n    model,\n    where,\n    deleteParent,\n  }: onDeleteArgs): Promise<BatchPayload | void> {\n    const results = (\n      await this.getDeleteArray(model, where, !!deleteParent)\n    ).reverse();\n    for (let i = 0; i < results.length; ++i) {\n      if (i + 1 === results.length && deleteParent) {\n        return await this.prisma[results[i].name].deleteMany({\n          where: results[i].where,\n        });\n      } else {\n        await this.prisma[results[i].name].deleteMany({\n          where: results[i].where,\n        });\n      }\n    }\n  }\n}\n","import { DMMF } from '@prisma/client/runtime';\nimport { GraphQLSchema } from 'graphql';\nimport { writeFileSync } from 'fs';\n\ninterface OptionsType {\n  dmmf?: DMMF.Document;\n  excludeFields?: string[];\n  filterInputs?: (input: DMMF.InputType) => DMMF.SchemaArg[];\n  doNotUseFieldUpdateOperationsInput?: boolean;\n}\n\nconst testedTypes: string[] = [];\n\nexport const hasEmptyTypeFields = (type: string, options?: OptionsType) => {\n  let schema = options?.dmmf?.schema;\n  if (!schema) {\n    const { Prisma } = require('@prisma/client');\n    schema = Prisma.dmmf?.schema;\n  }\n  testedTypes.push(type);\n  const inputObjectTypes = schema ? [...schema?.inputObjectTypes.prisma] : [];\n  if (schema?.inputObjectTypes.model)\n    inputObjectTypes.push(...schema.inputObjectTypes.model);\n\n  const inputType = inputObjectTypes.find((item) => item.name === type);\n  if (inputType) {\n    if (inputType.fields.length === 0) return true;\n    for (const field of inputType.fields) {\n      const fieldType = getInputType(field, options);\n      if (\n        fieldType.type !== type &&\n        fieldType.location === 'inputObjectTypes' &&\n        !testedTypes.includes(fieldType.type as string)\n      ) {\n        const state = hasEmptyTypeFields(fieldType.type as string, options);\n        if (state) return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport const getInputType = (\n  field: DMMF.SchemaArg,\n  options?: { doNotUseFieldUpdateOperationsInput?: boolean },\n) => {\n  let index: number = 0;\n  if (\n    options?.doNotUseFieldUpdateOperationsInput &&\n    field.inputTypes.length > 1 &&\n    (field.inputTypes[1].type as string).endsWith('FieldUpdateOperationsInput')\n  ) {\n    return field.inputTypes[index];\n  }\n  if (\n    field.inputTypes.length > 1 &&\n    (field.inputTypes[1].location === 'inputObjectTypes' ||\n      field.inputTypes[1].isList ||\n      field.inputTypes[1].type === 'Json')\n  ) {\n    index = 1;\n  }\n  return field.inputTypes[index];\n};\n\nexport function generateInputsString(options?: OptionsType) {\n  let schema = options?.dmmf?.schema;\n  if (!schema) {\n    const { Prisma } = require('@prisma/client');\n    schema = Prisma.dmmf?.schema;\n  }\n  let fileContent = `\n  scalar DateTime\n  \n  type BatchPayload {\n  count: Int!\n}\n`;\n  if (schema) {\n    const enums = [...schema.enumTypes.prisma];\n    if (schema.enumTypes.model) enums.push(...schema.enumTypes.model);\n    enums.forEach((item) => {\n      fileContent += `enum ${item.name} {`;\n      item.values.forEach((item2) => {\n        fileContent += `\n        ${item2}`;\n      });\n      fileContent += `}\n  \n  `;\n    });\n    const inputObjectTypes = [...schema.inputObjectTypes.prisma];\n    if (schema.inputObjectTypes.model)\n      inputObjectTypes.push(...schema.inputObjectTypes.model);\n\n    inputObjectTypes.forEach((input) => {\n      if (input.fields.length > 0) {\n        fileContent += `input ${input.name} {\n      `;\n        const inputFields =\n          typeof options?.filterInputs === 'function'\n            ? options.filterInputs(input)\n            : input.fields;\n        inputFields\n          .filter((field) => !options?.excludeFields?.includes(field.name))\n          .forEach((field) => {\n            const inputType = getInputType(field, options);\n            const hasEmptyType =\n              inputType.location === 'inputObjectTypes' &&\n              hasEmptyTypeFields(inputType.type as string, options);\n            if (!hasEmptyType) {\n              fileContent += `${field.name}: ${\n                inputType.isList ? `[${inputType.type}!]` : inputType.type\n              }${field.isRequired ? '!' : ''}\n        `;\n            }\n          });\n        fileContent += `}\n    \n  `;\n      }\n    });\n\n    schema?.outputObjectTypes.prisma\n      .filter(\n        (type) =>\n          type.name.includes('Aggregate') ||\n          type.name.endsWith('CountOutputType'),\n      )\n      .forEach((type) => {\n        fileContent += `type ${type.name} {\n      `;\n        type.fields\n          .filter((field) => !options?.excludeFields?.includes(field.name))\n          .forEach((field) => {\n            fileContent += `${field.name}: ${\n              field.outputType.isList\n                ? `[${field.outputType.type}!]`\n                : field.outputType.type\n            }${!field.isNullable ? '!' : ''}\n        `;\n          });\n        fileContent += `}\n    \n  `;\n      });\n  }\n  return fileContent;\n}\n\nexport const sdlInputs = (options?: OptionsType) => {\n  const gql = require('graphql-tag');\n  return gql`\n    ${generateInputsString(options)}\n  `;\n};\n\nexport const generateGraphQlSDLFile = (\n  schema: GraphQLSchema,\n  path: string = 'schema.graphql',\n) => {\n  const { printSchema } = require('graphql');\n  writeFileSync(path, printSchema(schema));\n};\n"],"names":["PrismaSelect","info","options","getModelMap","docs","name","value","match","asArray","replace","split","filter","v","includes","model","dataModel","find","item","documentation","field","fields","isObject","Array","isArray","mergeDeep","target","sources","length","source","shift","key","Object","assign","valueOf","filterBy","mergeObject","splitItem","newValue","getSelect","isAggregate","hasOwnProperty","select","valueWithFilter","modelName","selectObject","defaultFields","modelFields","filteredObject","keys","forEach","allowedProps","kind","subModelFilter","type","toString","arg","key2","availableArgs","returnType","models","dmmf","doc","push","datamodel","require","Prisma","graphqlFields","excludedFields","processArguments","_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","e","o","_this","pact","bind","observer","_isSettledPact","thenable","_forTo","array","body","check","i","reject","_cycle","_iteratorSymbol","Symbol","iterator","_forOf","step","next","done","_fixup","TypeError","values","_asyncIteratorSymbol","asyncIterator","PrismaDelete","prisma","getModel","getModelName","charAt","toLowerCase","slice","getFieldByType","fieldType","isList","getModelIdFieldName","isId","getOnDeleteFields","setFieldNull","where","modelId","fieldModelId","isRequired","fieldSelect","findMany","results","update","data","disconnect","getDeleteArray","whereInput","includeParent","cascadeFields","cascadeField","childField","deleteArray","nullFields","nullField","onDelete","deleteParent","reverse","deleteMany","getDMMF","testedTypes","hasEmptyTypeFields","schema","inputObjectTypes","inputType","getInputType","location","index","doNotUseFieldUpdateOperationsInput","inputTypes","endsWith","generateInputsString","fileContent","enums","enumTypes","item2","input","inputFields","filterInputs","excludeFields","hasEmptyType","outputObjectTypes","outputType","isNullable","sdlInputs","gql","generateGraphQlSDLFile","path","printSchema","writeFileSync"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsCaA,YAAb;AAKE,wBACUC,IADV,EAEUC,OAFV;AACU,aAAA,GAAAD,IAAA;AACA,gBAAA,GAAAC,OAAA;AANF,sBAAA,GAAgB,CAAC,OAAD,EAAU,SAAV,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,MAAvC,CAAhB;AACA,qBAAA,GAAe,CAAC,QAAD,CAAf;AACA,oBAAA,GAAuB,KAAvB;AAYJ;;AAfN,eAyDiBC,WAzDjB,GAyDU,qBAAmBC,IAAnB,EAAkCC,IAAlC;AACN,QAAMC,KAAK,GAAGF,IAAH,aAAGA,IAAH,uBAAGA,IAAI,CAAEG,KAAN,CAAY,gCAAZ,CAAd;;AACA,QAAID,KAAK,IAAID,IAAb,EAAmB;AACjB,UAAMG,OAAO,GAAGF,KAAK,CAAC,CAAD,CAAL,CACbG,OADa,CACL,IADK,EACC,EADD,EAEbC,KAFa,CAEP,GAFO,EAGbC,MAHa,CAGN,UAACC,CAAD;AAAA,eAAOA,CAAP;AAAA,OAHM,CAAhB;AAIA,aAAOJ,OAAO,CAACK,QAAR,CAAiBR,IAAjB,CAAP;AACD;;AACD,WAAO,KAAP;AACD,GAnEH;;AAAA;;AAAA,SAqEUS,KArEV,GAqEU,eAAMT,IAAN;AACN,WAAO,KAAKU,SAAL,CAAeC,IAAf,CACL,UAACC,IAAD;AAAA,aACEA,IAAI,CAACZ,IAAL,KAAcA,IAAd,IACAL,YAAY,CAACG,WAAb,CAAyBc,IAAI,CAACC,aAA9B,EAA6Cb,IAA7C,CAFF;AAAA,KADK,CAAP;AAKD,GA3EH;;AAAA,SA6EUc,KA7EV,GA6EU,eAAMd,IAAN,EAAoBS,KAApB;AACN,WAAOA,KAAP,aAAOA,KAAP,uBAAOA,KAAK,CAAEM,MAAP,CAAcJ,IAAd,CAAmB,UAACC,IAAD;AAAA,aAAUA,IAAI,CAACZ,IAAL,KAAcA,IAAxB;AAAA,KAAnB,CAAP;AACD,GA/EH;;AAAA,eAiFSgB,QAjFT,GAiFE,kBAAgBJ,IAAhB;AACE,WAAOA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAAxB,IAAoC,CAACK,KAAK,CAACC,OAAN,CAAcN,IAAd,CAA5C;AACD,GAnFH;;AAAA,eAqFSO,SArFT,GAqFE,mBAAiBC,MAAjB;sCAAiCC;AAAAA,MAAAA;;;AAC/B,QAAI,CAACA,OAAO,CAACC,MAAb,EAAqB,OAAOF,MAAP;AACrB,QAAMG,MAAM,GAAQF,OAAO,CAACG,KAAR,EAApB;;AAEA,QAAI7B,YAAY,CAACqB,QAAb,CAAsBI,MAAtB,KAAiCzB,YAAY,CAACqB,QAAb,CAAsBO,MAAtB,CAArC,EAAoE;AAClE,WAAK,IAAME,GAAX,IAAkBF,MAAlB,EAA0B;AACxB,YAAI5B,YAAY,CAACqB,QAAb,CAAsBO,MAAM,CAACE,GAAD,CAA5B,CAAJ,EAAwC;AAAA;;AACtC,cAAI,CAACL,MAAM,CAACK,GAAD,CAAX,EAAkBC,MAAM,CAACC,MAAP,CAAcP,MAAd,uCAAyBK,GAAzB,IAA+B,EAA/B;AAClB9B,UAAAA,YAAY,CAACwB,SAAb,CAAuBC,MAAM,CAACK,GAAD,CAA7B,EAAoCF,MAAM,CAACE,GAAD,CAA1C;AACD,SAHD,MAGO;AAAA;;AACLC,UAAAA,MAAM,CAACC,MAAP,CAAcP,MAAd,yCAAyBK,GAAzB,IAA+BF,MAAM,CAACE,GAAD,CAArC;AACD;AACF;AACF;;AAED,WAAO9B,YAAY,CAACwB,SAAb,OAAAxB,YAAY,GAAWyB,MAAX,SAAsBC,OAAtB,EAAnB;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvGF;;AAAA,SAqIEO,OArIF,GAqIE,iBAAQd,KAAR,EAAuBe,QAAvB,EAA0CC,WAA1C;QAA0CA;AAAAA,MAAAA,cAAmB;;;AAC3D,QAAMC,SAAS,GAAGjB,KAAK,CAACT,KAAN,CAAY,GAAZ,CAAlB;AACA,QAAI2B,QAAQ,GAAG,KAAKC,SAAL,CAAe,KAAKlB,MAApB,CAAf;;AACA,yDAAoBgB,SAApB,wCAA+B;AAAA,UAApBjB,MAAoB;;AAC7B,UAAI,KAAKoB,WAAL,IAAoBF,QAAQ,CAACG,cAAT,CAAwBrB,MAAxB,CAAxB,EAAwD;AACtDkB,QAAAA,QAAQ,GAAGA,QAAQ,CAAClB,MAAD,CAAnB;AACD,OAFD,MAEO,IACL,CAAC,KAAKoB,WAAN,IACAF,QAAQ,CAACG,cAAT,CAAwB,QAAxB,CADA,IAEAH,QAAQ,CAACI,MAAT,CAAgBD,cAAhB,CAA+BrB,MAA/B,CAHK,EAIL;AACAkB,QAAAA,QAAQ,GAAGA,QAAQ,CAACI,MAAT,CAAgBtB,MAAhB,CAAX;AACD,OANM,MAMA;AACL,eAAO,EAAP;AACD;AACF;;AACD,WAAOe,QAAQ,GACXlC,YAAY,CAACwB,SAAb,CAAuB,KAAKU,QAAL,CAAcA,QAAd,EAAwBG,QAAxB,CAAvB,EAA0DF,WAA1D,CADW,GAEXE,QAFJ;AAGD;AAED;;;;;;;;;;;AA1JF;;AAAA,SAqKEK,eArKF,GAqKE,yBAAgBC,SAAhB;AACE,WAAO,KAAKT,QAAL,CAAcS,SAAd,EAAyB,KAAKL,SAAL,CAAe,KAAKlB,MAApB,CAAzB,CAAP;AACD,GAvKH;;AAAA,SAyKUc,QAzKV,GAyKU,kBAASS,SAAT,EAA4BC,YAA5B;;;AACN,QAAM9B,KAAK,GAAG,KAAKA,KAAL,CAAW6B,SAAX,CAAd;;AACA,QAAI7B,KAAK,IAAI,OAAO8B,YAAP,KAAwB,QAArC,EAA+C;AAC7C,UAAIC,aAAa,GAAG,EAApB;;AACA,UAAI,KAAKA,aAAL,IAAsB,KAAKA,aAAL,CAAmBF,SAAnB,CAA1B,EAAyD;AACvD,YAAMG,WAAW,GAAG,KAAKD,aAAL,CAAmBF,SAAnB,CAApB;AACAE,QAAAA,aAAa,GACX,OAAOC,WAAP,KAAuB,UAAvB,GACIA,WAAW,CAACF,YAAY,CAACH,MAAd,CADf,GAEIK,WAHN;AAID;;AACD,UAAMC,cAAc,gBACfH,YADe;AAElBH,QAAAA,MAAM,eAAOI,aAAP;AAFY,QAApB;;AAIAd,MAAAA,MAAM,CAACiB,IAAP,CAAYJ,YAAY,CAACH,MAAzB,EAAiCQ,OAAjC,CAAyC,UAACnB,GAAD;AACvC,YAAI,KAAI,CAACoB,YAAL,CAAkBrC,QAAlB,CAA2BiB,GAA3B,CAAJ,EAAqC;AACnCiB,UAAAA,cAAc,CAACN,MAAf,CAAsBX,GAAtB,IAA6Bc,YAAY,CAACH,MAAb,CAAoBX,GAApB,CAA7B;AACD,SAFD,MAEO;AACL,cAAMX,KAAK,GAAG,KAAI,CAACA,KAAL,CAAWW,GAAX,EAAgBhB,KAAhB,CAAd;;AACA,cAAIK,KAAJ,EAAW;AACT,gBAAIA,KAAK,CAACgC,IAAN,KAAe,QAAnB,EAA6B;AAC3BJ,cAAAA,cAAc,CAACN,MAAf,CAAsBX,GAAtB,IAA6B,IAA7B;AACD,aAFD,MAEO;AACL,kBAAMsB,cAAc,GAAG,KAAI,CAAClB,QAAL,CACrBf,KAAK,CAACkC,IAAN,CAAWC,QAAX,EADqB,EAErBV,YAAY,CAACH,MAAb,CAAoBX,GAApB,CAFqB,CAAvB;;AAIA,kBAAIC,MAAM,CAACiB,IAAP,CAAYI,cAAc,CAACX,MAA3B,EAAmCd,MAAnC,GAA4C,CAAhD,EAAmD;AACjDoB,gBAAAA,cAAc,CAACN,MAAf,CAAsBX,GAAtB,IAA6BsB,cAA7B;AACD;AACF;AACF;AACF;AACF,OAnBD;AAoBA,aAAOL,cAAP;AACD,KAlCD,MAkCO;AACL,aAAOH,YAAP;AACD;AACF,GAhNH;;AAAA,SAkNUN,SAlNV,GAkNU,mBAAUlB,MAAV;;;AACN,QAAMwB,YAAY,GAAQ,KAAKL,WAAL,GAAmB,EAAnB,GAAwB;AAAEE,MAAAA,MAAM,EAAE;AAAV,KAAlD;AACAV,IAAAA,MAAM,CAACiB,IAAP,CAAY5B,MAAZ,EAAoB6B,OAApB,CAA4B,UAACnB,GAAD;AAC1B,UAAIC,MAAM,CAACiB,IAAP,CAAY5B,MAAM,CAACU,GAAD,CAAlB,EAAyBH,MAAzB,KAAoC,CAAxC,EAA2C;AACzC,YAAI,MAAI,CAACY,WAAT,EAAsB;AACpBK,UAAAA,YAAY,CAACd,GAAD,CAAZ,GAAoB,IAApB;AACD,SAFD,MAEO;AACLc,UAAAA,YAAY,CAACH,MAAb,CAAoBX,GAApB,IAA2B,IAA3B;AACD;AACF,OAND,MAMO,IAAIA,GAAG,KAAK,aAAZ,EAA2B;AAChCV,QAAAA,MAAM,CAACU,GAAD,CAAN,CAAYmB,OAAZ,CAAoB,UAACM,GAAD;AAClBxB,UAAAA,MAAM,CAACiB,IAAP,CAAYO,GAAZ,EAAiBN,OAAjB,CAAyB,UAACO,IAAD;AACvB,gBAAI,MAAI,CAACC,aAAL,CAAmB5C,QAAnB,CAA4B2C,IAA5B,CAAJ,EAAuC;AACrCZ,cAAAA,YAAY,CAACY,IAAD,CAAZ,GAAqBD,GAAG,CAACC,IAAD,CAAH,CAAUlD,KAA/B;AACD;AACF,WAJD;AAKD,SAND;AAOD,OARM,MAQA;AACL,YAAI,MAAI,CAACiC,WAAT,EAAsB;AACpBK,UAAAA,YAAY,CAACd,GAAD,CAAZ,GAAoB,MAAI,CAACQ,SAAL,CAAelB,MAAM,CAACU,GAAD,CAArB,CAApB;AACD,SAFD,MAEO;AACLc,UAAAA,YAAY,CAACH,MAAb,CAAoBX,GAApB,IAA2B,MAAI,CAACQ,SAAL,CAAelB,MAAM,CAACU,GAAD,CAArB,CAA3B;AACD;AACF;AACF,KAtBD;AAuBA,WAAOc,YAAP;AACD,GA5OH;;AAAA;AAAA;AAAA;AAkBI,UAAMc,UAAU,GAAG,KAAKzD,IAAL,CAAUyD,UAAV,CAChBJ,QADgB,GAEhB7C,OAFgB,CAER,IAFQ,EAEF,EAFE,EAGhBA,OAHgB,CAGR,KAHQ,EAGD,EAHC,EAIhBA,OAJgB,CAIR,IAJQ,EAIF,EAJE,CAAnB;AAKA,WAAK8B,WAAL,GAAmBmB,UAAU,CAAC7C,QAAX,CAAoB,WAApB,CAAnB;AACA,aAAO,KAAK6B,eAAL,CAAqBgB,UAArB,CAAP;AACD;AAzBH;AAAA;AAAA;;;AA4BI,UAAMC,MAAM,GAAiB,EAA7B;;AACA,2BAAI,KAAKzD,OAAT,kDAAI,cAAc0D,IAAlB,EAAwB;AAAA;;AACtB,+BAAK1D,OAAL,kEAAc0D,IAAd,CAAmBX,OAAnB,CAA2B,UAACY,GAAD;AACzBF,UAAAA,MAAM,CAACG,IAAP,OAAAH,MAAM,EAASE,GAAG,CAACE,SAAJ,CAAcJ,MAAvB,CAAN;AACD,SAFD;AAGD,OAJD,MAIO;AAAA,uBACcK,OAAO,CAAC,gBAAD,CADrB;AAAA,YACGC,MADH,YACGA,MADH;;AAEL,YAAIA,MAAM,CAACL,IAAP,IAAeK,MAAM,CAACL,IAAP,CAAYG,SAA/B,EAA0C;AACxCJ,UAAAA,MAAM,CAACG,IAAP,OAAAH,MAAM,EAASM,MAAM,CAACL,IAAP,CAAYG,SAAZ,CAAsBJ,MAA/B,CAAN;AACD;AACF;;AACD,aAAOA,MAAP;AACD;AAxCH;AAAA;AAAA;;;AA2CI,+BAAO,KAAKzD,OAAZ,mDAAO,eAAc2C,aAArB;AACD;AA5CH;AAAA;AAAA;AA+CI,aAAOqB,aAAa,CAClB,KAAKjE,IADa,EAElB,EAFkB,EAGlB;AACEkE,QAAAA,cAAc,EAAE,CAAC,YAAD,CADlB;AAEEC,QAAAA,gBAAgB,EAAE;AAFpB,OAHkB,CAApB;AAQD;AAvDH;;AAAA;AAAA;;AC3CA;AACA,AAAO,IAAMC,KAAK,gBAAiB,YAAW;AAC7C,WAASA,KAAT,GAAiB;;AACjBA,EAAAA,KAAK,CAACC,SAAN,CAAgBC,IAAhB,GAAuB,UAASC,WAAT,EAAsBC,UAAtB,EAAkC;AACxD,QAAMC,MAAM,GAAG,IAAIL,KAAJ,EAAf;AACA,QAAMM,KAAK,GAAG,KAAKC,CAAnB;;AACA,QAAID,KAAJ,EAAW;AACV,UAAME,QAAQ,GAAGF,KAAK,GAAG,CAAR,GAAYH,WAAZ,GAA0BC,UAA3C;;AACA,UAAII,QAAJ,EAAc;AACb,YAAI;AACHC,UAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYG,QAAQ,CAAC,KAAKjE,CAAN,CAApB,CAAP;AACA,SAFD,CAEE,OAAOmE,CAAP,EAAU;AACXD,UAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYK,CAAZ,CAAP;AACA;;AACD,eAAOL,MAAP;AACA,OAPD,MAOO;AACN,eAAO,IAAP;AACA;AACD;;AACD,SAAKM,CAAL,GAAS,UAASC,KAAT,EAAgB;AACxB,UAAI;AACH,YAAM3E,KAAK,GAAG2E,KAAK,CAACrE,CAApB;;AACA,YAAIqE,KAAK,CAACL,CAAN,GAAU,CAAd,EAAiB;AAChBE,UAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYF,WAAW,GAAGA,WAAW,CAAClE,KAAD,CAAd,GAAwBA,KAA/C,CAAP;AACA,SAFD,MAEO,IAAImE,UAAJ,EAAgB;AACtBK,UAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYD,UAAU,CAACnE,KAAD,CAAtB,CAAP;AACA,SAFM,MAEA;AACNwE,UAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYpE,KAAZ,CAAP;AACA;AACD,OATD,CASE,OAAOyE,CAAP,EAAU;AACXD,QAAAA,OAAO,CAACJ,MAAD,EAAS,CAAT,EAAYK,CAAZ,CAAP;AACA;AACD,KAbD;;AAcA,WAAOL,MAAP;AACA,GA/BD;;AAgCA,SAAOL,KAAP;AACA,CAnCiC,EAA3B;;AAsCP,AAAO,SAASS,OAAT,CAAiBI,IAAjB,EAAuBP,KAAvB,EAA8BrE,KAA9B,EAAqC;AAC3C,MAAI,CAAC4E,IAAI,CAACN,CAAV,EAAa;AACZ,QAAItE,KAAK,YAAY+D,KAArB,EAA4B;AAC3B,UAAI/D,KAAK,CAACsE,CAAV,EAAa;AACZ,YAAID,KAAK,GAAG,CAAZ,EAAe;AACdA,UAAAA,KAAK,GAAGrE,KAAK,CAACsE,CAAd;AACA;;AACDtE,QAAAA,KAAK,GAAGA,KAAK,CAACM,CAAd;AACA,OALD,MAKO;AACNN,QAAAA,KAAK,CAAC0E,CAAN,GAAUF,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBD,IAAnB,EAAyBP,KAAzB,CAAV;AACA;AACA;AACD;;AACD,QAAIrE,KAAK,IAAIA,KAAK,CAACiE,IAAnB,EAAyB;AACxBjE,MAAAA,KAAK,CAACiE,IAAN,CAAWO,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBD,IAAnB,EAAyBP,KAAzB,CAAX,EAA4CG,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBD,IAAnB,EAAyB,CAAzB,CAA5C;AACA;AACA;;AACDA,IAAAA,IAAI,CAACN,CAAL,GAASD,KAAT;AACAO,IAAAA,IAAI,CAACtE,CAAL,GAASN,KAAT;AACA,QAAM8E,QAAQ,GAAGF,IAAI,CAACF,CAAtB;;AACA,QAAII,QAAJ,EAAc;AACbA,MAAAA,QAAQ,CAACF,IAAD,CAAR;AACA;AACD;AACD;AAED,AAAO,SAASG,cAAT,CAAwBC,QAAxB,EAAkC;AACxC,SAAOA,QAAQ,YAAYjB,KAApB,IAA6BiB,QAAQ,CAACV,CAAT,GAAa,CAAjD;AACA;;AA+CD,AAAO,SAASW,MAAT,CAAgBC,KAAhB,EAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AAC1C,MAAIC,CAAC,GAAG,CAAC,CAAT;AAAA,MAAYT,IAAZ;AAAA,MAAkBU,MAAlB;;AACA,WAASC,MAAT,CAAgBnB,MAAhB,EAAwB;AACvB,QAAI;AACH,aAAO,EAAEiB,CAAF,GAAMH,KAAK,CAAC7D,MAAZ,KAAuB,CAAC+D,KAAD,IAAU,CAACA,KAAK,EAAvC,CAAP,EAAmD;AAClDhB,QAAAA,MAAM,GAAGe,IAAI,CAACE,CAAD,CAAb;;AACA,YAAIjB,MAAM,IAAIA,MAAM,CAACH,IAArB,EAA2B;AAC1B,cAAIc,cAAc,CAACX,MAAD,CAAlB,EAA4B;AAC3BA,YAAAA,MAAM,GAAGA,MAAM,CAAC9D,CAAhB;AACA,WAFD,MAEO;AACN8D,YAAAA,MAAM,CAACH,IAAP,CAAYsB,MAAZ,EAAoBD,MAAM,KAAKA,MAAM,GAAGd,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBD,IAAI,GAAG,IAAIb,KAAJ,EAA1B,EAAuC,CAAvC,CAAd,CAA1B;AACA;AACA;AACD;AACD;;AACD,UAAIa,IAAJ,EAAU;AACTJ,QAAAA,OAAO,CAACI,IAAD,EAAO,CAAP,EAAUR,MAAV,CAAP;AACA,OAFD,MAEO;AACNQ,QAAAA,IAAI,GAAGR,MAAP;AACA;AACD,KAjBD,CAiBE,OAAOK,CAAP,EAAU;AACXD,MAAAA,OAAO,CAACI,IAAI,KAAKA,IAAI,GAAG,IAAIb,KAAJ,EAAZ,CAAL,EAA+B,CAA/B,EAAkCU,CAAlC,CAAP;AACA;AACD;;AACDc,EAAAA,MAAM;;AACN,SAAOX,IAAP;AACA;AAGD,AAqBO,IAAMY,eAAe,gBAAiB,OAAOC,MAAP,KAAkB,WAAlB,GAAiCA,MAAM,CAACC,QAAP,KAAoBD,MAAM,CAACC,QAAP,gBAAkBD,MAAM,CAAC,iBAAD,CAA5C,CAAjC,GAAqG,YAA3I;AAGP;;AACA,AAAO,SAASE,MAAT,CAAgBxE,MAAhB,EAAwBgE,IAAxB,EAA8BC,KAA9B,EAAqC;AAC3C,MAAI,OAAOjE,MAAM,CAACqE,eAAD,CAAb,KAAmC,UAAvC,EAAmD;AAAA,QAEzCD,MAFyC,GAElD,SAASA,MAAT,CAAgBnB,MAAhB,EAAwB;AACvB,UAAI;AACH,eAAO,CAAC,CAACwB,IAAI,GAAGF,QAAQ,CAACG,IAAT,EAAR,EAAyBC,IAA1B,KAAmC,CAACV,KAAD,IAAU,CAACA,KAAK,EAAnD,CAAP,EAA+D;AAC9DhB,UAAAA,MAAM,GAAGe,IAAI,CAACS,IAAI,CAAC5F,KAAN,CAAb;;AACA,cAAIoE,MAAM,IAAIA,MAAM,CAACH,IAArB,EAA2B;AAC1B,gBAAIc,cAAc,CAACX,MAAD,CAAlB,EAA4B;AAC3BA,cAAAA,MAAM,GAAGA,MAAM,CAAC9D,CAAhB;AACA,aAFD,MAEO;AACN8D,cAAAA,MAAM,CAACH,IAAP,CAAYsB,MAAZ,EAAoBD,MAAM,KAAKA,MAAM,GAAGd,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBD,IAAI,GAAG,IAAIb,KAAJ,EAA1B,EAAuC,CAAvC,CAAd,CAA1B;AACA;AACA;AACD;AACD;;AACD,YAAIa,IAAJ,EAAU;AACTJ,UAAAA,OAAO,CAACI,IAAD,EAAO,CAAP,EAAUR,MAAV,CAAP;AACA,SAFD,MAEO;AACNQ,UAAAA,IAAI,GAAGR,MAAP;AACA;AACD,OAjBD,CAiBE,OAAOK,CAAP,EAAU;AACXD,QAAAA,OAAO,CAACI,IAAI,KAAKA,IAAI,GAAG,IAAIb,KAAJ,EAAZ,CAAL,EAA+B,CAA/B,EAAkCU,CAAlC,CAAP;AACA;AACD,KAvBiD;;AAClD,QAAIiB,QAAQ,GAAGvE,MAAM,CAACqE,eAAD,CAAN,EAAf;AAAA,QAA0CI,IAA1C;AAAA,QAAgDhB,IAAhD;AAAA,QAAsDU,MAAtD;;AAuBAC,IAAAA,MAAM;;AACN,QAAIG,QAAQ,UAAZ,EAAqB;AACpB,UAAIK,MAAM,GAAG,SAATA,MAAS,CAAS/F,KAAT,EAAgB;AAC5B,YAAI;AACH,cAAI,CAAC4F,IAAI,CAACE,IAAV,EAAgB;AACfJ,YAAAA,QAAQ,UAAR;AACA;AACD,SAJD,CAIE,OAAMjB,CAAN,EAAS;;AAEX,eAAOzE,KAAP;AACA,OARD;;AASA,UAAI4E,IAAI,IAAIA,IAAI,CAACX,IAAjB,EAAuB;AACtB,eAAOW,IAAI,CAACX,IAAL,CAAU8B,MAAV,EAAkB,UAAStB,CAAT,EAAY;AACpC,gBAAMsB,MAAM,CAACtB,CAAD,CAAZ;AACA,SAFM,CAAP;AAGA;;AACDsB,MAAAA,MAAM;AACN;;AACD,WAAOnB,IAAP;AACA,GA5C0C;;;AA8C3C,MAAI,EAAE,YAAYzD,MAAd,CAAJ,EAA2B;AAC1B,UAAM,IAAI6E,SAAJ,CAAc,wBAAd,CAAN;AACA,GAhD0C;;;AAkD3C,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlE,MAAM,CAACE,MAA3B,EAAmCgE,CAAC,EAApC,EAAwC;AACvCY,IAAAA,MAAM,CAACzC,IAAP,CAAYrC,MAAM,CAACkE,CAAD,CAAlB;AACA;;AACD,SAAOJ,MAAM,CAACgB,MAAD,EAAS,UAASZ,CAAT,EAAY;AAAE,WAAOF,IAAI,CAACc,MAAM,CAACZ,CAAD,CAAP,CAAX;AAAyB,GAAhD,EAAkDD,KAAlD,CAAb;AACA;AAED,AAAO,IAAMc,oBAAoB,gBAAiB,OAAOT,MAAP,KAAkB,WAAlB,GAAiCA,MAAM,CAACU,aAAP,KAAyBV,MAAM,CAACU,aAAP,gBAAuBV,MAAM,CAAC,sBAAD,CAAtD,CAAjC,GAAoH,iBAA/J;;AChNP;;;;;;;;;;;;;;;;;;AAkBA,IAAaW,YAAb;AACE,wBACUC,MADV,EAEUzG,OAFV;AACU,eAAA,GAAAyG,MAAA;AACA,gBAAA,GAAAzG,OAAA;AACN;;AAJN;;AAAA,SAmBU0G,QAnBV,GAmBU,kBAASjE,SAAT;;;AACN,8BAAO,KAAK5B,SAAZ,oDAAO,gBAAgB4C,MAAhB,CAAuB3C,IAAvB,CAA4B,UAACC,IAAD;AAAA,aAAUA,IAAI,CAACZ,IAAL,KAAcsC,SAAxB;AAAA,KAA5B,CAAP;AACD,GArBH;;AAAA,eAuBiBkE,YAvBjB,GAuBU,sBAAoBlE,SAApB;AACN,WAAOA,SAAS,CAACmE,MAAV,CAAiB,CAAjB,EAAoBC,WAApB,KAAoCpE,SAAS,CAACqE,KAAV,CAAgB,CAAhB,CAA3C;AACD,GAzBH;;AAAA,SA2BUC,cA3BV,GA2BU,wBAAetE,SAAf,EAAkCuE,SAAlC;;;AACN,6BAAO,KAAKN,QAAL,CAAcjE,SAAd,CAAP,mDAAO,eAA0BvB,MAA1B,CAAiCJ,IAAjC,CACL,UAACC,IAAD;AAAA,aAAUA,IAAI,CAACoC,IAAL,KAAc6D,SAAd,IAA2B,CAACjG,IAAI,CAACkG,MAA3C;AAAA,KADK,CAAP;AAGD,GA/BH;;AAAA,SAiCUC,mBAjCV,GAiCU,6BAAoBzE,SAApB;;;AACN,8BAAO,KAAKiE,QAAL,CAAcjE,SAAd,CAAP,6EAAO,gBAA0BvB,MAA1B,CAAiCJ,IAAjC,CAAsC,UAACC,IAAD;AAAA,aAAUA,IAAI,CAACoG,IAAf;AAAA,KAAtC,CAAP,0DAAO,sBAA4DhH,IAAnE;AACD,GAnCH;;AAAA,SAqCUiH,iBArCV,GAqCU,2BAAkB3E,SAAlB,EAAqCU,IAArC;;;AACN,8BAAO,KAAKuD,QAAL,CAAcjE,SAAd,CAAP,oDAAO,gBAA0BvB,MAA1B,CAAiCT,MAAjC,CACL,UAACM,IAAD;AAAA;;AAAA,aACE,wBAAAA,IAAI,CAACC,aAAL,4EAAoBL,QAApB,CAA6B,WAA7B,+BACAI,IAAI,CAACC,aADL,yDACA,qBAAoBL,QAApB,CAA6BwC,IAA7B,CADA,CADF;AAAA,KADK,CAAP;AAKD,GA3CH;;AAAA,SA6CgBkE,YA7ChB,yBA6C6B5E,SA7C7B,EA6CgDxB,KA7ChD,EA6CmEqG,KA7CnE;AAAA;mBA+CoB;;AADhB,UAAMnH,IAAI,GAAGqG,YAAY,CAACG,YAAb,CAA0BlE,SAA1B,CAAb;;AACA,UAAM8E,OAAO,GAAG,OAAKL,mBAAL,CAAyBzE,SAAzB,CAAhB;;AACA,UAAM+E,YAAY,GAAG,OAAKN,mBAAL,CAAyBjG,KAAK,CAACkC,IAAN,CAAWC,QAAX,EAAzB,CAArB;;;YACImE,OAAO,IAAIC,YAAX,IAA2B,CAACvG,KAAK,CAACwG;;;AACpC,cAAMC,WAAW,GAAGzG,KAAK,CAACgG,MAAN,oBACbhG,KAAK,CAACd,IADO,IACA;AAAEoC,YAAAA,MAAM,yBAAKiF,YAAL,IAAoB,IAApB;AAAR,WADA,UAEhB,EAFJ;iCAGsB,OAAKf,MAAL,CAAYtG,IAAZ,EAAkBwH,QAAlB,CAA2B;AAC/CL,YAAAA,KAAK,EAALA,KAD+C;AAE/C/E,YAAAA,MAAM,sCACHgF,OADG,IACO,IADP,cAEDG,WAFC;AAFyC,WAA3B,kBAAhBE;0BAOeA,mBAAVpD,QAAmB;AAAA;AAAA,oBACxB,EAAEvD,KAAK,CAACgG,MAAN,IAAgBzC,MAAM,CAACvD,KAAK,CAACd,IAAP,CAAN,CAAmBsB,MAAnB,KAA8B,CAAhD,CADwB;AAAA;;AAAA,yCAEpB,OAAKgF,MAAL,CAAYtG,IAAZ,EAAkB0H,MAAlB,CAAyB;AAC7BP,oBAAAA,KAAK,uBACFC,OADE,IACQ/C,MAAM,CAAC+C,OAAD,CADd,SADwB;AAI7BO,oBAAAA,IAAI,qBACD7G,KAAK,CAACd,IADL,IACY;AACZ4H,sBAAAA,UAAU,EAAE9G,KAAK,CAACgG,MAAN,GAAezC,MAAM,CAACvD,KAAK,CAACd,IAAP,CAArB,GAAoC;AADpC,qBADZ;AAJyB,mBAAzB,CAFoB;AAAA;AAAA;;AAAA;AAa7B;;;;AAEJ,KA3EH;AAAA;AAAA;AAAA;;AAAA,SA6EgB6H,cA7EhB,2BA8EIvF,SA9EJ,EA+EIwF,UA/EJ,EAgFIC,aAhFJ;AAAA,QAgFIA,aAhFJ;AAgFIA,MAAAA,aAhFJ,GAgFoB,IAhFpB;AAAA;;AAAA;;AAkGI,YAAMC,aAAa,GAAG,OAAKf,iBAAL,CAAuB3E,SAAvB,EAAkC,SAAlC,CAAtB;;;cACI0F;0BACyBA,yBAAhBC,cAA+B;AACxC,kBAAMC,UAAU,GAAG,OAAKtB,cAAL,CACjBqB,YAAY,CAACjF,IAAb,CAAkBC,QAAlB,EADiB,EAEjBX,SAFiB,CAAnB;;AADwC;AAAA,oBAKpC4F,UALoC;AAAA;AAAA,wBAMlCD,YAAY,CAACjF,IAAb,KAAsBV,SANY;AAAA;;AAAA,mCAOpC6F,WAAW,CAAC1E,IAPwB;AAAA,6CAQxB,OAAKoE,cAAL,CAAoBI,YAAY,CAACjF,IAAb,CAAkBC,QAAlB,EAApB,qDACPiF,UAAU,CAAClI,IADJ,IACW8H,UADX,yBARwB;AAOpC,mDAAAK,WAAW,QAAX;AAPoC;AAAA;AAAA;;AAapCA,sBAAAA,WAAW,CAAC1E,IAAZ,CAAiB;AACfzD,wBAAAA,IAAI,EAAEqG,YAAY,CAACG,YAAb,CAA0BlE,SAA1B,CADS;AAEf6E,wBAAAA,KAAK,yBACFe,UAAU,CAAClI,IADT,IACgB8H,UADhB;AAFU,uBAAjB;AAboC;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAqBzC;;;;;AAGH,iBAAOK,WAAP;aAAOA;;;mBAjCY;;AATnB,UAAMA,WAAW,GAAiBJ,aAAa,GAC3C,CACE;AACE/H,QAAAA,IAAI,EAAEqG,YAAY,CAACG,YAAb,CAA0BlE,SAA1B,CADR;AAEE6E,QAAAA,KAAK,EAAEW;AAFT,OADF,CAD2C,GAO3C,EAPJ;;AASA,UAAMM,UAAU,GAAG,OAAKnB,iBAAL,CAAuB3E,SAAvB,EAAkC,UAAlC,CAAnB;;;YACI8F;+BACsBA,sBAAbC,WAAyB;AAAA,mCAC5B,OAAKnB,YAAL,CAAkB5E,SAAlB,EAA6B+F,SAA7B,EAAwCP,UAAxC,CAD4B;AAEnC;;;;;;;AA8BJ,KA7HH;AAAA;AAAA;AAAA;AA8HE;;;;;;;;;;;;;AA9HF;;AAAA,SA2IQQ,QA3IR;AAAA,QA4II7H,KA5IJ,SA4IIA,KA5IJ;AAAA,QA6II0G,KA7IJ,SA6IIA,KA7IJ;AAAA,QA8IIoB,YA9IJ,SA8IIA,YA9IJ;;AAAA;mBAiJY;;6BAAA,OAAKV,cAAL,CAAoBpH,KAApB,EAA2B0G,KAA3B,EAAkC,CAAC,CAACoB,YAApC;;;AADR,YAAMd,OAAO,GAAG,sBAEde,OAFc,EAAhB;;sBAGoBf,mBAAXnC,GAAgC;AAAA;AAAA,gBACnCA,CAAC,GAAG,CAAJ,KAAUmC,OAAO,CAACnG,MAAlB,IAA4BiH,YADO;AAAA;AAAA,qCAExB,OAAKjC,MAAL,CAAYmB,OAAO,CAACnC,CAAD,CAAP,CAAWtF,IAAvB,EAA6ByI,UAA7B,CAAwC;AACnDtB,gBAAAA,KAAK,EAAEM,OAAO,CAACnC,CAAD,CAAP,CAAW6B;AADiC,eAAxC,CAFwB;AAAA;AAAA,qCAM/B,OAAKb,MAAL,CAAYmB,OAAO,CAACnC,CAAD,CAAP,CAAWtF,IAAvB,EAA6ByI,UAA7B,CAAwC;AAC5CtB,gBAAAA,KAAK,EAAEM,OAAO,CAACnC,CAAD,CAAP,CAAW6B;AAD0B,eAAxC,CAN+B;AAAA;AAAA;AAUxC;;;;AACF,KA9JH;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;qBAOuBxD,OAAO,CAAC,gBAAD;UAAlBC,kBAAAA;;AACR,aAAOA,MAAM,CAACL,IAAd;AACD;AATH;AAAA;AAAA;;;AAYI,2BAAI,KAAK1D,OAAT,kDAAI,cAAc0D,IAAlB,EAAwB;AAAA;;AACtB,iCAAO,KAAK1D,OAAZ,0EAAO,eAAc0D,IAArB,wDAAO,oBAAoBG,SAA3B;AACD,OAFD,MAEO;AAAA;;AACL,gCAAO,KAAKgF,OAAZ,kDAAO,cAAchF,SAArB;AACD;AACF;AAjBH;;AAAA;AAAA;;;;;;;;;;;ACxBA,IAAMiF,WAAW,GAAa,EAA9B;AAEA,IAAaC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAC5F,IAAD,EAAenD,OAAf;;;AAChC,MAAIgJ,MAAM,GAAGhJ,OAAH,aAAGA,OAAH,wCAAGA,OAAO,CAAE0D,IAAZ,kDAAG,cAAesF,MAA5B;;AACA,MAAI,CAACA,MAAL,EAAa;AAAA;;AAAA,mBACQlF,OAAO,CAAC,gBAAD,CADf;AAAA,QACHC,MADG,YACHA,MADG;;AAEXiF,IAAAA,MAAM,mBAAGjF,MAAM,CAACL,IAAV,iDAAG,aAAasF,MAAtB;AACD;;AACDF,EAAAA,WAAW,CAAClF,IAAZ,CAAiBT,IAAjB;AACA,MAAM8F,gBAAgB,GAAGD,MAAM,wBAAOA,MAAP,4CAAO,QAAQC,gBAAR,CAAyBxC,MAAhC,IAA0C,EAAzE;AACA,kBAAIuC,MAAJ,6CAAI,SAAQC,gBAAR,CAAyBrI,KAA7B,EACEqI,gBAAgB,CAACrF,IAAjB,OAAAqF,gBAAgB,EAASD,MAAM,CAACC,gBAAP,CAAwBrI,KAAjC,CAAhB;AAEF,MAAMsI,SAAS,GAAGD,gBAAgB,CAACnI,IAAjB,CAAsB,UAACC,IAAD;AAAA,WAAUA,IAAI,CAACZ,IAAL,KAAcgD,IAAxB;AAAA,GAAtB,CAAlB;;AACA,MAAI+F,SAAJ,EAAe;AACb,QAAIA,SAAS,CAAChI,MAAV,CAAiBO,MAAjB,KAA4B,CAAhC,EAAmC,OAAO,IAAP;;AACnC,yDAAoByH,SAAS,CAAChI,MAA9B,wCAAsC;AAAA,UAA3BD,KAA2B;AACpC,UAAM+F,SAAS,GAAGmC,YAAY,CAAClI,KAAD,EAAQjB,OAAR,CAA9B;;AACA,UACEgH,SAAS,CAAC7D,IAAV,KAAmBA,IAAnB,IACA6D,SAAS,CAACoC,QAAV,KAAuB,kBADvB,IAEA,CAACN,WAAW,CAACnI,QAAZ,CAAqBqG,SAAS,CAAC7D,IAA/B,CAHH,EAIE;AACA,YAAMsB,KAAK,GAAGsE,kBAAkB,CAAC/B,SAAS,CAAC7D,IAAX,EAA2BnD,OAA3B,CAAhC;AACA,YAAIyE,KAAJ,EAAW,OAAO,IAAP;AACZ;AACF;AACF;;AACD,SAAO,KAAP;AACD,CA3BM;AA6BP,IAAa0E,YAAY,GAAG,SAAfA,YAAe,CAC1BlI,KAD0B,EAE1BjB,OAF0B;AAI1B,MAAIqJ,KAAK,GAAW,CAApB;;AACA,MACE,CAAArJ,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEsJ,kCAAT,KACArI,KAAK,CAACsI,UAAN,CAAiB9H,MAAjB,GAA0B,CAD1B,IAECR,KAAK,CAACsI,UAAN,CAAiB,CAAjB,EAAoBpG,IAApB,CAAoCqG,QAApC,CAA6C,4BAA7C,CAHH,EAIE;AACA,WAAOvI,KAAK,CAACsI,UAAN,CAAiBF,KAAjB,CAAP;AACD;;AACD,MACEpI,KAAK,CAACsI,UAAN,CAAiB9H,MAAjB,GAA0B,CAA1B,KACCR,KAAK,CAACsI,UAAN,CAAiB,CAAjB,EAAoBH,QAApB,KAAiC,kBAAjC,IACCnI,KAAK,CAACsI,UAAN,CAAiB,CAAjB,EAAoBtC,MADrB,IAEChG,KAAK,CAACsI,UAAN,CAAiB,CAAjB,EAAoBpG,IAApB,KAA6B,MAH/B,CADF,EAKE;AACAkG,IAAAA,KAAK,GAAG,CAAR;AACD;;AACD,SAAOpI,KAAK,CAACsI,UAAN,CAAiBF,KAAjB,CAAP;AACD,CArBM;AAuBP,SAAgBI,qBAAqBzJ;;;AACnC,MAAIgJ,MAAM,GAAGhJ,OAAH,aAAGA,OAAH,yCAAGA,OAAO,CAAE0D,IAAZ,mDAAG,eAAesF,MAA5B;;AACA,MAAI,CAACA,MAAL,EAAa;AAAA;;AAAA,oBACQlF,OAAO,CAAC,gBAAD,CADf;AAAA,QACHC,MADG,aACHA,MADG;;AAEXiF,IAAAA,MAAM,oBAAGjF,MAAM,CAACL,IAAV,kDAAG,cAAasF,MAAtB;AACD;;AACD,MAAIU,WAAW,uEAAf;;AAOA,MAAIV,MAAJ,EAAY;AAAA;;AACV,QAAMW,KAAK,aAAOX,MAAM,CAACY,SAAP,CAAiBnD,MAAxB,CAAX;AACA,QAAIuC,MAAM,CAACY,SAAP,CAAiBhJ,KAArB,EAA4B+I,KAAK,CAAC/F,IAAN,OAAA+F,KAAK,EAASX,MAAM,CAACY,SAAP,CAAiBhJ,KAA1B,CAAL;AAC5B+I,IAAAA,KAAK,CAAC5G,OAAN,CAAc,UAAChC,IAAD;AACZ2I,MAAAA,WAAW,cAAY3I,IAAI,CAACZ,IAAjB,OAAX;AACAY,MAAAA,IAAI,CAACsF,MAAL,CAAYtD,OAAZ,CAAoB,UAAC8G,KAAD;AAClBH,QAAAA,WAAW,mBACTG,KADF;AAED,OAHD;AAIAH,MAAAA,WAAW,eAAX;AAGD,KATD;AAUA,QAAMT,gBAAgB,aAAOD,MAAM,CAACC,gBAAP,CAAwBxC,MAA/B,CAAtB;AACA,QAAIuC,MAAM,CAACC,gBAAP,CAAwBrI,KAA5B,EACEqI,gBAAgB,CAACrF,IAAjB,OAAAqF,gBAAgB,EAASD,MAAM,CAACC,gBAAP,CAAwBrI,KAAjC,CAAhB;AAEFqI,IAAAA,gBAAgB,CAAClG,OAAjB,CAAyB,UAAC+G,KAAD;AACvB,UAAIA,KAAK,CAAC5I,MAAN,CAAaO,MAAb,GAAsB,CAA1B,EAA6B;AAC3BiI,QAAAA,WAAW,eAAaI,KAAK,CAAC3J,IAAnB,eAAX;AAEA,YAAM4J,WAAW,GACf,QAAO/J,OAAP,aAAOA,OAAP,uBAAOA,OAAO,CAAEgK,YAAhB,MAAiC,UAAjC,GACIhK,OAAO,CAACgK,YAAR,CAAqBF,KAArB,CADJ,GAEIA,KAAK,CAAC5I,MAHZ;AAIA6I,QAAAA,WAAW,CACRtJ,MADH,CACU,UAACQ,KAAD;AAAA;;AAAA,iBAAW,EAACjB,OAAD,aAACA,OAAD,gDAACA,OAAO,CAAEiK,aAAV,0DAAC,sBAAwBtJ,QAAxB,CAAiCM,KAAK,CAACd,IAAvC,CAAD,CAAX;AAAA,SADV,EAEG4C,OAFH,CAEW,UAAC9B,KAAD;AACP,cAAMiI,SAAS,GAAGC,YAAY,CAAClI,KAAD,EAAQjB,OAAR,CAA9B;AACA,cAAMkK,YAAY,GAChBhB,SAAS,CAACE,QAAV,KAAuB,kBAAvB,IACAL,kBAAkB,CAACG,SAAS,CAAC/F,IAAX,EAA2BnD,OAA3B,CAFpB;;AAGA,cAAI,CAACkK,YAAL,EAAmB;AACjBR,YAAAA,WAAW,IAAOzI,KAAK,CAACd,IAAb,WACT+I,SAAS,CAACjC,MAAV,SAAuBiC,SAAS,CAAC/F,IAAjC,UAA4C+F,SAAS,CAAC/F,IAD7C,KAERlC,KAAK,CAACwG,UAAN,GAAmB,GAAnB,GAAyB,EAFjB,gBAAX;AAID;AACF,SAbH;AAcAiC,QAAAA,WAAW,iBAAX;AAGD;AACF,KA1BD;AA4BA,gBAAAV,MAAM,UAAN,4CAAQmB,iBAAR,CAA0B1D,MAA1B,CACGhG,MADH,CAEI,UAAC0C,IAAD;AAAA,aACEA,IAAI,CAAChD,IAAL,CAAUQ,QAAV,CAAmB,WAAnB,KACAwC,IAAI,CAAChD,IAAL,CAAUqJ,QAAV,CAAmB,iBAAnB,CAFF;AAAA,KAFJ,EAMGzG,OANH,CAMW,UAACI,IAAD;AACPuG,MAAAA,WAAW,cAAYvG,IAAI,CAAChD,IAAjB,eAAX;AAEAgD,MAAAA,IAAI,CAACjC,MAAL,CACGT,MADH,CACU,UAACQ,KAAD;AAAA;;AAAA,eAAW,EAACjB,OAAD,aAACA,OAAD,iDAACA,OAAO,CAAEiK,aAAV,2DAAC,uBAAwBtJ,QAAxB,CAAiCM,KAAK,CAACd,IAAvC,CAAD,CAAX;AAAA,OADV,EAEG4C,OAFH,CAEW,UAAC9B,KAAD;AACPyI,QAAAA,WAAW,IAAOzI,KAAK,CAACd,IAAb,WACTc,KAAK,CAACmJ,UAAN,CAAiBnD,MAAjB,SACQhG,KAAK,CAACmJ,UAAN,CAAiBjH,IADzB,UAEIlC,KAAK,CAACmJ,UAAN,CAAiBjH,IAHZ,KAIR,CAAClC,KAAK,CAACoJ,UAAP,GAAoB,GAApB,GAA0B,EAJlB,gBAAX;AAMD,OATH;AAUAX,MAAAA,WAAW,iBAAX;AAGD,KAtBH;AAuBD;;AACD,SAAOA,WAAP;AACD;AAED,IAAaY,SAAS,GAAG,SAAZA,SAAY,CAACtK,OAAD;AACvB,MAAMuK,GAAG,GAAGzG,OAAO,CAAC,aAAD,CAAnB;;AACA,SAAOyG,GAAP,oBACId,oBAAoB,CAACzJ,OAAD,CADxB;AAGD,CALM;AAOP,IAAawK,sBAAsB,GAAG,SAAzBA,sBAAyB,CACpCxB,MADoC,EAEpCyB,IAFoC;MAEpCA;AAAAA,IAAAA,OAAe;;;kBAES3G,OAAO,CAAC,SAAD;MAAvB4G,wBAAAA;;AACRC,EAAAA,gBAAa,CAACF,IAAD,EAAOC,WAAW,CAAC1B,MAAD,CAAlB,CAAb;AACD,CANM;;;;;;;;;;"}