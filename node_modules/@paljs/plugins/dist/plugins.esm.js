import graphqlFields from 'graphql-fields';
import { writeFileSync } from 'fs';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/**
 * Convert `info` to select object accepted by `prisma client`.
 * @param info - GraphQLResolveInfo.
 * @example
 * // Graphql query
 * {
 *    findManyUser{
 *      id
 *      posts(where: { title: { contains: "a" } }, first: 10) {
 *        id
 *        comments{
 *          id
 *        }
 *      }
 *    }
 * }
 * // convert to
 * {
 *  select: {
 *    id: true,
 *    posts: {
 *      select: { id: true, comments: { select: { id: true } } },
 *      where: { title: { contains: "a" } },
 *      first: 10
 *    }
 *  }
 * }
 *
 * // Use
 *
 * const select = new PrismaSelect(info);
 *
 * prisma.user.findMany({
 *  ...args,
 *  ...select.value,
 * })
 *
 **/

var PrismaSelect = /*#__PURE__*/function () {
  function PrismaSelect(info, options) {
    this.info = info;
    this.options = options;
    this.availableArgs = ['where', 'orderBy', 'skip', 'cursor', 'take'];
    this.allowedProps = ['_count'];
    this.isAggregate = false;
  }

  PrismaSelect.getModelMap = function getModelMap(docs, name) {
    var value = docs === null || docs === void 0 ? void 0 : docs.match(/@PrismaSelect.map\(\[(.*?)\]\)/);

    if (value && name) {
      var asArray = value[1].replace(/ /g, '').split(',').filter(function (v) {
        return v;
      });
      return asArray.includes(name);
    }

    return false;
  };

  var _proto = PrismaSelect.prototype;

  _proto.model = function model(name) {
    return this.dataModel.find(function (item) {
      return item.name === name || PrismaSelect.getModelMap(item.documentation, name);
    });
  };

  _proto.field = function field(name, model) {
    return model === null || model === void 0 ? void 0 : model.fields.find(function (item) {
      return item.name === name;
    });
  };

  PrismaSelect.isObject = function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
  };

  PrismaSelect.mergeDeep = function mergeDeep(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    if (!sources.length) return target;
    var source = sources.shift();

    if (PrismaSelect.isObject(target) && PrismaSelect.isObject(source)) {
      for (var key in source) {
        if (PrismaSelect.isObject(source[key])) {
          var _Object$assign;

          if (!target[key]) Object.assign(target, (_Object$assign = {}, _Object$assign[key] = {}, _Object$assign));
          PrismaSelect.mergeDeep(target[key], source[key]);
        } else {
          var _Object$assign2;

          Object.assign(target, (_Object$assign2 = {}, _Object$assign2[key] = source[key], _Object$assign2));
        }
      }
    }

    return PrismaSelect.mergeDeep.apply(PrismaSelect, [target].concat(sources));
  }
  /**
   * Get nested value from select object.
   * @param field - name of field in select object.
   * @param filterBy - Model name as you have in schema.prisma file.
   * @param mergeObject
   * @example
   * // Graphql query
   * {
   *    findManyUser{
   *      id
   *      posts{
   *        id
   *        comments{
   *          id
   *        }
   *      }
   *    }
   * }
   *
   * // when you need to get more nested fields just add `.`
   * PrismaSelect.valueOf('posts.comments', 'Comment');
   * // return
   * { select: { id: true } }
   *
   * PrismaSelect.valueOf('posts', 'Post');
   *
   * // return
   * { select: { id: true, comments: { select: { id: true } } } }
   *
   **/
  ;

  _proto.valueOf = function valueOf(field, filterBy, mergeObject) {
    if (mergeObject === void 0) {
      mergeObject = {};
    }

    var splitItem = field.split('.');
    var newValue = this.getSelect(this.fields);

    for (var _iterator = _createForOfIteratorHelperLoose(splitItem), _step; !(_step = _iterator()).done;) {
      var _field = _step.value;

      if (this.isAggregate && newValue.hasOwnProperty(_field)) {
        newValue = newValue[_field];
      } else if (!this.isAggregate && newValue.hasOwnProperty('select') && newValue.select.hasOwnProperty(_field)) {
        newValue = newValue.select[_field];
      } else {
        return {};
      }
    }

    return filterBy ? PrismaSelect.mergeDeep(this.filterBy(filterBy, newValue), mergeObject) : newValue;
  }
  /**
   * Work with this method if your GraphQL type name not like Schema model name.
   * @param modelName - Model name as you have in schema.prisma file.
   * @example
   * // normal call
   * const select = new PrismaSelect(info).value
   *
   * // With filter will filter select object with provided schema model name
   * const select = new PrismaSelect(info).valueWithFilter('User');
   *
   **/
  ;

  _proto.valueWithFilter = function valueWithFilter(modelName) {
    return this.filterBy(modelName, this.getSelect(this.fields));
  };

  _proto.filterBy = function filterBy(modelName, selectObject) {
    var _this = this;

    var model = this.model(modelName);

    if (model && typeof selectObject === 'object') {
      var defaultFields = {};

      if (this.defaultFields && this.defaultFields[modelName]) {
        var modelFields = this.defaultFields[modelName];
        defaultFields = typeof modelFields === 'function' ? modelFields(selectObject.select) : modelFields;
      }

      var filteredObject = _extends({}, selectObject, {
        select: _extends({}, defaultFields)
      });

      Object.keys(selectObject.select).forEach(function (key) {
        if (_this.allowedProps.includes(key)) {
          filteredObject.select[key] = selectObject.select[key];
        } else {
          var field = _this.field(key, model);

          if (field) {
            if (field.kind !== 'object') {
              filteredObject.select[key] = true;
            } else {
              var subModelFilter = _this.filterBy(field.type.toString(), selectObject.select[key]);

              if (Object.keys(subModelFilter.select).length > 0) {
                filteredObject.select[key] = subModelFilter;
              }
            }
          }
        }
      });
      return filteredObject;
    } else {
      return selectObject;
    }
  };

  _proto.getSelect = function getSelect(fields) {
    var _this2 = this;

    var selectObject = this.isAggregate ? {} : {
      select: {}
    };
    Object.keys(fields).forEach(function (key) {
      if (Object.keys(fields[key]).length === 0) {
        if (_this2.isAggregate) {
          selectObject[key] = true;
        } else {
          selectObject.select[key] = true;
        }
      } else if (key === '__arguments') {
        fields[key].forEach(function (arg) {
          Object.keys(arg).forEach(function (key2) {
            if (_this2.availableArgs.includes(key2)) {
              selectObject[key2] = arg[key2].value;
            }
          });
        });
      } else {
        if (_this2.isAggregate) {
          selectObject[key] = _this2.getSelect(fields[key]);
        } else {
          selectObject.select[key] = _this2.getSelect(fields[key]);
        }
      }
    });
    return selectObject;
  };

  _createClass(PrismaSelect, [{
    key: "value",
    get: function get() {
      var returnType = this.info.returnType.toString().replace(/]/g, '').replace(/\[/g, '').replace(/!/g, '');
      this.isAggregate = returnType.includes('Aggregate');
      return this.valueWithFilter(returnType);
    }
  }, {
    key: "dataModel",
    get: function get() {
      var _this$options;

      var models = [];

      if ((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dmmf) {
        var _this$options2;

        (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.dmmf.forEach(function (doc) {
          models.push.apply(models, doc.datamodel.models);
        });
      } else {
        var _require = require('@prisma/client'),
            Prisma = _require.Prisma;

        if (Prisma.dmmf && Prisma.dmmf.datamodel) {
          models.push.apply(models, Prisma.dmmf.datamodel.models);
        }
      }

      return models;
    }
  }, {
    key: "defaultFields",
    get: function get() {
      var _this$options3;

      return (_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.defaultFields;
    }
  }, {
    key: "fields",
    get: function get() {
      return graphqlFields(this.info, {}, {
        excludedFields: ['__typename'],
        processArguments: true
      });
    }
  }]);

  return PrismaSelect;
}();

// A type of promise-like that resolves synchronously and supports only one observer
var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}(); // Settles a pact synchronously

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
} // Converts argument to a function that always returns a Promise

function _forTo(array, body, check) {
  var i = -1,
      pact,
      reject;

  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }

      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }

  _cycle();

  return pact;
} // Asynchronously iterate through an object's properties (including properties inherited from the prototype)
var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy

function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    var _cycle = function _cycle(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }

        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };

    var iterator = target[_iteratorSymbol](),
        step,
        pact,
        reject;

    _cycle();

    if (iterator["return"]) {
      var _fixup = function _fixup(value) {
        try {
          if (!step.done) {
            iterator["return"]();
          }
        } catch (e) {}

        return value;
      };

      if (pact && pact.then) {
        return pact.then(_fixup, function (e) {
          throw _fixup(e);
        });
      }

      _fixup();
    }

    return pact;
  } // No support for Symbol.iterator


  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  } // Handle live collections properly


  var values = [];

  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }

  return _forTo(values, function (i) {
    return body(values[i]);
  }, check);
}
var _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing

/**
 * Handle all relation onDelete type
 * @param prisma - optional arg you can send your client class.
 * @param options - optional arg you can send your custom options { dmmf?: DMMF.Document }.
 * @example
 * const prisma = new PrismaClient({log: ['query']});
 * const prismaDelete = new PrismaDelete(prisma);
 *
 * // or new PrismaDelete(); we will create new client and use
 *
 * // use onDelete method
 * prismaDelete.onDelete({
 *  model: 'User',
 *  where: { id: 1 },
 *  deleteParent: true // if true will also delete user record default false
 * });
 *
 **/
var PrismaDelete = /*#__PURE__*/function () {
  function PrismaDelete(prisma, options) {
    this.prisma = prisma;
    this.options = options;
  }

  var _proto = PrismaDelete.prototype;

  _proto.getModel = function getModel(modelName) {
    var _this$dataModel;

    return (_this$dataModel = this.dataModel) === null || _this$dataModel === void 0 ? void 0 : _this$dataModel.models.find(function (item) {
      return item.name === modelName;
    });
  };

  PrismaDelete.getModelName = function getModelName(modelName) {
    return modelName.charAt(0).toLowerCase() + modelName.slice(1);
  };

  _proto.getFieldByType = function getFieldByType(modelName, fieldType) {
    var _this$getModel;

    return (_this$getModel = this.getModel(modelName)) === null || _this$getModel === void 0 ? void 0 : _this$getModel.fields.find(function (item) {
      return item.type === fieldType && !item.isList;
    });
  };

  _proto.getModelIdFieldName = function getModelIdFieldName(modelName) {
    var _this$getModel2, _this$getModel2$field;

    return (_this$getModel2 = this.getModel(modelName)) === null || _this$getModel2 === void 0 ? void 0 : (_this$getModel2$field = _this$getModel2.fields.find(function (item) {
      return item.isId;
    })) === null || _this$getModel2$field === void 0 ? void 0 : _this$getModel2$field.name;
  };

  _proto.getOnDeleteFields = function getOnDeleteFields(modelName, type) {
    var _this$getModel3;

    return (_this$getModel3 = this.getModel(modelName)) === null || _this$getModel3 === void 0 ? void 0 : _this$getModel3.fields.filter(function (item) {
      var _item$documentation, _item$documentation2;

      return ((_item$documentation = item.documentation) === null || _item$documentation === void 0 ? void 0 : _item$documentation.includes('@onDelete')) && ((_item$documentation2 = item.documentation) === null || _item$documentation2 === void 0 ? void 0 : _item$documentation2.includes(type));
    });
  };

  _proto.setFieldNull = function setFieldNull(modelName, field, where) {
    try {
      var _this2 = this;

      var name = PrismaDelete.getModelName(modelName);

      var modelId = _this2.getModelIdFieldName(modelName);

      var fieldModelId = _this2.getModelIdFieldName(field.type.toString());

      return Promise.resolve(function () {
        if (modelId && fieldModelId && !field.isRequired) {
          var _select, _ref, _extends2;

          var fieldSelect = field.isList ? (_ref = {}, _ref[field.name] = {
            select: (_select = {}, _select[fieldModelId] = true, _select)
          }, _ref) : {};
          return Promise.resolve(_this2.prisma[name].findMany({
            where: where,
            select: _extends((_extends2 = {}, _extends2[modelId] = true, _extends2), fieldSelect)
          })).then(function (results) {
            return _forOf(results, function (result) {
              var _temp = function () {
                if (!(field.isList && result[field.name].length === 0)) {
                  var _where, _data;

                  return Promise.resolve(_this2.prisma[name].update({
                    where: (_where = {}, _where[modelId] = result[modelId], _where),
                    data: (_data = {}, _data[field.name] = {
                      disconnect: field.isList ? result[field.name] : true
                    }, _data)
                  })).then(function () {});
                }
              }();

              if (_temp && _temp.then) return _temp.then(function () {});
            });
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getDeleteArray = function getDeleteArray(modelName, whereInput, includeParent) {
    if (includeParent === void 0) {
      includeParent = true;
    }

    try {
      var _temp8 = function _temp8() {
        var cascadeFields = _this4.getOnDeleteFields(modelName, 'CASCADE');

        var _temp5 = function () {
          if (cascadeFields) {
            return _forOf(cascadeFields, function (cascadeField) {
              var childField = _this4.getFieldByType(cascadeField.type.toString(), modelName);

              var _temp4 = function () {
                if (childField) {
                  var _temp10 = function () {
                    if (cascadeField.type !== modelName) {
                      var _this4$getDeleteArray;

                      var _push2 = deleteArray.push;
                      return Promise.resolve(_this4.getDeleteArray(cascadeField.type.toString(), (_this4$getDeleteArray = {}, _this4$getDeleteArray[childField.name] = whereInput, _this4$getDeleteArray))).then(function (_this3$getDeleteArray) {
                        _push2.call.apply(_push2, [deleteArray].concat(_this3$getDeleteArray));
                      });
                    } else {
                      var _where2;

                      deleteArray.push({
                        name: PrismaDelete.getModelName(modelName),
                        where: (_where2 = {}, _where2[childField.name] = whereInput, _where2)
                      });
                    }
                  }();

                  if (_temp10 && _temp10.then) return _temp10.then(function () {});
                }
              }();

              if (_temp4 && _temp4.then) return _temp4.then(function () {});
            });
          }
        }();

        return _temp5 && _temp5.then ? _temp5.then(function () {
          return deleteArray;
        }) : deleteArray;
      };

      var _this4 = this;

      var deleteArray = includeParent ? [{
        name: PrismaDelete.getModelName(modelName),
        where: whereInput
      }] : [];

      var nullFields = _this4.getOnDeleteFields(modelName, 'SET_NULL');

      var _temp9 = function () {
        if (nullFields) {
          var _temp11 = _forOf(nullFields, function (nullField) {
            return Promise.resolve(_this4.setFieldNull(modelName, nullField, whereInput)).then(function () {});
          });

          if (_temp11 && _temp11.then) return _temp11.then(function () {});
        }
      }();

      return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(_temp8) : _temp8(_temp9));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Handle all relation onDelete type
   * @param onDeleteArgs - Object with model data.
   * @return count of deleted records if deleteParent is true
   * @example
   * const prismaDelete = new PrismaDelete();
   * prismaDelete.onDelete({
   *  model: 'User',
   *  where: { id: 1 },
   *  deleteParent: true // if true will also delete user record default false
   * });
   *
   **/
  ;

  _proto.onDelete = function onDelete(_ref2) {
    var model = _ref2.model,
        where = _ref2.where,
        deleteParent = _ref2.deleteParent;

    try {
      var _this6 = this;

      return Promise.resolve(_this6.getDeleteArray(model, where, !!deleteParent)).then(function (_this5$getDeleteArray) {
        var _exit = false;

        var results = _this5$getDeleteArray.reverse();

        return _forTo(results, function (i) {
          return function () {
            if (i + 1 === results.length && deleteParent) {
              _exit = true;
              return Promise.resolve(_this6.prisma[results[i].name].deleteMany({
                where: results[i].where
              }));
            } else {
              return Promise.resolve(_this6.prisma[results[i].name].deleteMany({
                where: results[i].where
              })).then(function () {});
            }
          }();
        }, function () {
          return _exit;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _createClass(PrismaDelete, [{
    key: "getDMMF",
    get: function get() {
      var _require = require('@prisma/client'),
          Prisma = _require.Prisma;

      return Prisma.dmmf;
    }
  }, {
    key: "dataModel",
    get: function get() {
      var _this$options;

      if ((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dmmf) {
        var _this$options2, _this$options2$dmmf;

        return (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : (_this$options2$dmmf = _this$options2.dmmf) === null || _this$options2$dmmf === void 0 ? void 0 : _this$options2$dmmf.datamodel;
      } else {
        var _this$getDMMF;

        return (_this$getDMMF = this.getDMMF) === null || _this$getDMMF === void 0 ? void 0 : _this$getDMMF.datamodel;
      }
    }
  }]);

  return PrismaDelete;
}();

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n    ", "\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var testedTypes = [];
var hasEmptyTypeFields = function hasEmptyTypeFields(type, options) {
  var _options$dmmf, _schema, _schema2;

  var schema = options === null || options === void 0 ? void 0 : (_options$dmmf = options.dmmf) === null || _options$dmmf === void 0 ? void 0 : _options$dmmf.schema;

  if (!schema) {
    var _Prisma$dmmf;

    var _require = require('@prisma/client'),
        Prisma = _require.Prisma;

    schema = (_Prisma$dmmf = Prisma.dmmf) === null || _Prisma$dmmf === void 0 ? void 0 : _Prisma$dmmf.schema;
  }

  testedTypes.push(type);
  var inputObjectTypes = schema ? [].concat((_schema = schema) === null || _schema === void 0 ? void 0 : _schema.inputObjectTypes.prisma) : [];
  if ((_schema2 = schema) === null || _schema2 === void 0 ? void 0 : _schema2.inputObjectTypes.model) inputObjectTypes.push.apply(inputObjectTypes, schema.inputObjectTypes.model);
  var inputType = inputObjectTypes.find(function (item) {
    return item.name === type;
  });

  if (inputType) {
    if (inputType.fields.length === 0) return true;

    for (var _iterator = _createForOfIteratorHelperLoose(inputType.fields), _step; !(_step = _iterator()).done;) {
      var field = _step.value;
      var fieldType = getInputType(field, options);

      if (fieldType.type !== type && fieldType.location === 'inputObjectTypes' && !testedTypes.includes(fieldType.type)) {
        var state = hasEmptyTypeFields(fieldType.type, options);
        if (state) return true;
      }
    }
  }

  return false;
};
var getInputType = function getInputType(field, options) {
  var index = 0;

  if ((options === null || options === void 0 ? void 0 : options.doNotUseFieldUpdateOperationsInput) && field.inputTypes.length > 1 && field.inputTypes[1].type.endsWith('FieldUpdateOperationsInput')) {
    return field.inputTypes[index];
  }

  if (field.inputTypes.length > 1 && (field.inputTypes[1].location === 'inputObjectTypes' || field.inputTypes[1].isList || field.inputTypes[1].type === 'Json')) {
    index = 1;
  }

  return field.inputTypes[index];
};
function generateInputsString(options) {
  var _options$dmmf2;

  var schema = options === null || options === void 0 ? void 0 : (_options$dmmf2 = options.dmmf) === null || _options$dmmf2 === void 0 ? void 0 : _options$dmmf2.schema;

  if (!schema) {
    var _Prisma$dmmf2;

    var _require2 = require('@prisma/client'),
        Prisma = _require2.Prisma;

    schema = (_Prisma$dmmf2 = Prisma.dmmf) === null || _Prisma$dmmf2 === void 0 ? void 0 : _Prisma$dmmf2.schema;
  }

  var fileContent = "\n  scalar DateTime\n  \n  type BatchPayload {\n  count: Int!\n}\n";

  if (schema) {
    var _schema3;

    var enums = [].concat(schema.enumTypes.prisma);
    if (schema.enumTypes.model) enums.push.apply(enums, schema.enumTypes.model);
    enums.forEach(function (item) {
      fileContent += "enum " + item.name + " {";
      item.values.forEach(function (item2) {
        fileContent += "\n        " + item2;
      });
      fileContent += "}\n  \n  ";
    });
    var inputObjectTypes = [].concat(schema.inputObjectTypes.prisma);
    if (schema.inputObjectTypes.model) inputObjectTypes.push.apply(inputObjectTypes, schema.inputObjectTypes.model);
    inputObjectTypes.forEach(function (input) {
      if (input.fields.length > 0) {
        fileContent += "input " + input.name + " {\n      ";
        var inputFields = typeof (options === null || options === void 0 ? void 0 : options.filterInputs) === 'function' ? options.filterInputs(input) : input.fields;
        inputFields.filter(function (field) {
          var _options$excludeField;

          return !(options === null || options === void 0 ? void 0 : (_options$excludeField = options.excludeFields) === null || _options$excludeField === void 0 ? void 0 : _options$excludeField.includes(field.name));
        }).forEach(function (field) {
          var inputType = getInputType(field, options);
          var hasEmptyType = inputType.location === 'inputObjectTypes' && hasEmptyTypeFields(inputType.type, options);

          if (!hasEmptyType) {
            fileContent += field.name + ": " + (inputType.isList ? "[" + inputType.type + "!]" : inputType.type) + (field.isRequired ? '!' : '') + "\n        ";
          }
        });
        fileContent += "}\n    \n  ";
      }
    });
    (_schema3 = schema) === null || _schema3 === void 0 ? void 0 : _schema3.outputObjectTypes.prisma.filter(function (type) {
      return type.name.includes('Aggregate') || type.name.endsWith('CountOutputType');
    }).forEach(function (type) {
      fileContent += "type " + type.name + " {\n      ";
      type.fields.filter(function (field) {
        var _options$excludeField2;

        return !(options === null || options === void 0 ? void 0 : (_options$excludeField2 = options.excludeFields) === null || _options$excludeField2 === void 0 ? void 0 : _options$excludeField2.includes(field.name));
      }).forEach(function (field) {
        fileContent += field.name + ": " + (field.outputType.isList ? "[" + field.outputType.type + "!]" : field.outputType.type) + (!field.isNullable ? '!' : '') + "\n        ";
      });
      fileContent += "}\n    \n  ";
    });
  }

  return fileContent;
}
var sdlInputs = function sdlInputs(options) {
  var gql = require('graphql-tag');

  return gql(_templateObject(), generateInputsString(options));
};
var generateGraphQlSDLFile = function generateGraphQlSDLFile(schema, path) {
  if (path === void 0) {
    path = 'schema.graphql';
  }

  var _require3 = require('graphql'),
      printSchema = _require3.printSchema;

  writeFileSync(path, printSchema(schema));
};

export { PrismaDelete, PrismaSelect, generateGraphQlSDLFile, generateInputsString, getInputType, hasEmptyTypeFields, sdlInputs };
//# sourceMappingURL=plugins.esm.js.map
