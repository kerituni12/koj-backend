"use strict";
var RedisModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisModule = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const redis_manager_1 = require("./redis-manager");
const redis_providers_1 = require("./redis.providers");
const redis_constants_1 = require("./redis.constants");
const common_2 = require("./common");
const messages_1 = require("../messages");
const utils_1 = require("../utils");
const redis_logger_1 = require("./redis-logger");
const errors_1 = require("../errors");
/**
 * @public
 */
let RedisModule = RedisModule_1 = class RedisModule {
    constructor(options, clients) {
        this.options = options;
        this.clients = clients;
    }
    /**
     * Registers the module synchronously.
     */
    static forRoot(options = {}, isGlobal = true) {
        const redisClientProviders = (0, redis_providers_1.createRedisClientProviders)();
        const providers = [
            (0, redis_providers_1.createOptionsProvider)(options),
            redis_providers_1.redisClientsProvider,
            redis_manager_1.RedisManager,
            ...redisClientProviders
        ];
        return {
            global: isGlobal,
            module: RedisModule_1,
            providers,
            exports: [redis_manager_1.RedisManager, ...redisClientProviders]
        };
    }
    /**
     * Registers the module asynchronously.
     */
    static forRootAsync(options, isGlobal = true) {
        var _a;
        if (!options.useFactory && !options.useClass && !options.useExisting) {
            throw new errors_1.MissingConfigurationError(messages_1.MISSING_CONFIGURATION);
        }
        const redisClientProviders = (0, redis_providers_1.createRedisClientProviders)();
        const providers = [
            ...(0, redis_providers_1.createAsyncProviders)(options),
            redis_providers_1.redisClientsProvider,
            redis_manager_1.RedisManager,
            ...redisClientProviders,
            ...((_a = options.extraProviders) !== null && _a !== void 0 ? _a : [])
        ];
        return {
            global: isGlobal,
            module: RedisModule_1,
            imports: options.imports,
            providers,
            exports: [redis_manager_1.RedisManager, ...redisClientProviders]
        };
    }
    async onApplicationShutdown() {
        if (this.options.closeClient) {
            const result = await (0, common_2.quitClients)(this.clients);
            result.forEach(([namespace, quit]) => {
                if ((0, utils_1.isResolution)(namespace) && (0, utils_1.isRejection)(quit) && (0, utils_1.isError)(quit.reason)) {
                    redis_logger_1.logger.error(`${(0, utils_1.parseNamespace)(namespace.value)}: ${quit.reason.message}`);
                }
            });
        }
    }
};
RedisModule = RedisModule_1 = tslib_1.__decorate([
    (0, common_1.Module)({}),
    tslib_1.__param(0, (0, common_1.Inject)(redis_constants_1.REDIS_OPTIONS)),
    tslib_1.__param(1, (0, common_1.Inject)(redis_constants_1.REDIS_CLIENTS)),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], RedisModule);
exports.RedisModule = RedisModule;
