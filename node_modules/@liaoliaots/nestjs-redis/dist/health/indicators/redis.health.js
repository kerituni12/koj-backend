"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisHealthIndicator = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const terminus_1 = require("@nestjs/terminus");
const messages_1 = require("../../messages");
const utils_1 = require("../../utils");
/**
 * @public
 */
let RedisHealthIndicator = class RedisHealthIndicator extends terminus_1.HealthIndicator {
    /**
     * Checks a redis/cluster connection.
     *
     * @param key - The key which will be used for the result object
     * @param options - The extra options for check
     */
    async checkHealth(key, options) {
        var _a;
        const { type, client } = options;
        let isHealthy = false;
        try {
            if (!type)
                throw new Error(messages_1.MISSING_TYPE);
            if (type === 'redis') {
                const pong = await (0, utils_1.promiseTimeout)((_a = options.timeout) !== null && _a !== void 0 ? _a : 1000, client.ping());
                if (pong !== 'PONG')
                    throw new Error(messages_1.NOT_RESPONSIVE);
                if (!(0, utils_1.isNullish)(options.memoryThreshold)) {
                    const info = await client.info('memory');
                    if ((0, utils_1.parseUsedMemory)((0, utils_1.removeLineBreaks)(info)) > options.memoryThreshold) {
                        throw new Error(messages_1.ABNORMALLY_MEMORY_USAGE);
                    }
                }
            }
            else if (type === 'cluster') {
                const clusterInfo = await client.cluster('INFO');
                if (typeof clusterInfo === 'string') {
                    if (!clusterInfo.includes('cluster_state:ok'))
                        throw new Error(messages_1.FAILED_CLUSTER_STATE);
                }
                else
                    throw new Error(messages_1.CANNOT_BE_READ);
            }
            isHealthy = true;
        }
        catch (e) {
            const error = e;
            throw new terminus_1.HealthCheckError(error.message, this.getStatus(key, isHealthy, { message: error.message }));
        }
        return this.getStatus(key, isHealthy);
    }
};
RedisHealthIndicator = tslib_1.__decorate([
    (0, common_1.Injectable)({ scope: common_1.Scope.TRANSIENT })
], RedisHealthIndicator);
exports.RedisHealthIndicator = RedisHealthIndicator;
