
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  email: string
  username: string
  /**
   * @HideField()
   */
  password: string
  firstname: string
  lastname: string
  status: string
  role: string
  avatar: string | null
  provider: string
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdByName: string | null
  /**
   * @HideField({input: true})
   */
  createdAt: Date
  /**
   * @HideField({input: true})
   */
  updatedAt: Date | null
  extendData: Prisma.JsonValue | null
}

/**
 * Model Domain
 * 
 */
export type Domain = {
  id: number
  domain: string
  domainId: number
  status: string
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: number
  title: string
  content: string | null
  published: boolean | null
  authorId: number | null
  domainId: number
}

/**
 * Model Challenge
 * 
 */
export type Challenge = {
  id: number
  title: string
  slug: string
  acceptedLanguages: number[]
  languages: Prisma.JsonValue | null
  rate: number | null
  audience: string
  functionName: string | null
  /**
   * @HideField({input: true})
   */
  commentCount: number | null
  contestId: number | null
  status: string
  categoryId: number | null
  description: string | null
  companyTags: number[]
  contributors: Prisma.JsonValue | null
  examples: Prisma.JsonValue | null
  inputs: Prisma.JsonValue | null
  structs: Prisma.JsonValue | null
  types: Prisma.JsonValue | null
  output: string
  highlightSolutionCount: number | null
  hint: Prisma.JsonValue | null
  isFavorited: boolean
  officalSolutionCount: number | null
  testcases: Prisma.JsonValue | null
  difficulty: string
  likes: number
  dislikes: number
  solutions: Prisma.JsonValue | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdByName: string | null
  /**
   * @HideField({input: true})
   */
  createdAt: Date
  /**
   * @HideField({input: true})
   */
  updatedAt: Date | null
}

/**
 * Model Submission
 * 
 */
export type Submission = {
  id: number
  languageId: string | null
  challengeId: number | null
  content: string
  result: Prisma.JsonValue | null
  info: Prisma.JsonValue | null
  ip: string | null
  shared: boolean
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdAt: Date
}

/**
 * Model SubmissionContest
 * 
 */
export type SubmissionContest = {
  id: number
  languageId: string | null
  contestId: number | null
  challengeId: number | null
  content: string
  result: Prisma.JsonValue | null
  ip: string | null
  shared: boolean
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdAt: Date
}

/**
 * Model SubmissionStatistic
 * 
 */
export type SubmissionStatistic = {
  id: number
  challengeId: number | null
  languageId: string | null
  score: number
  submitCount: number
  info: Prisma.JsonValue | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  lastSubmitTime: Date
}

/**
 * Model SubmissionContestStatistic
 * 
 */
export type SubmissionContestStatistic = {
  id: number
  contestId: number | null
  info: Prisma.JsonValue | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  slug: string
  status: string
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
}

/**
 * Model TopicTag
 * 
 */
export type TopicTag = {
  id: number
  name: string
  slug: string
  status: string
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
}

/**
 * Model Language
 * 
 */
export type Language = {
  id: number
  title: string
  extension: string
  statusId: number
}

/**
 * Model Status
 * 
 */
export type Status = {
  id: number
  description: string
  type: string
}

/**
 * Model Group
 * 
 */
export type Group = {
  id: number
  name: string
  key: string
  status: string
  description: string | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdByName: string | null
  /**
   * @HideField({input: true})
   */
  createdAt: Date
  /**
   * @HideField({input: true})
   */
  updatedAt: Date | null
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: number
  key: string
  name: string
  description: string | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdByName: string | null
  /**
   * @HideField({input: true})
   */
  createdAt: Date
  /**
   * @HideField({input: true})
   */
  updatedAt: Date | null
}

/**
 * Model Policy
 * 
 */
export type Policy = {
  id: number
  /**
   * @HideField({input: true, output:true})
   */
  ptype: string
  subject: string
  object: string
  action: string
  effect: string
  effectWith: string
  condition: string | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
  /**
   * @HideField({input: true, output:true})
   */
  createdById: number | null
  /**
   * @HideField({input: true})
   */
  createdByUsername: string | null
  createdByName: string | null
  /**
   * @HideField({input: true})
   */
  createdAt: Date
  /**
   * @HideField({input: true})
   */
  updatedAt: Date | null
}

/**
 * Model RoleGroup
 * 
 */
export type RoleGroup = {
  id: number
  ptype: string
  role: string | null
  rule: string | null
  /**
   * @HideField({input: true, output:true})
   */
  domainId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<GlobalReject>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<GlobalReject>;

  /**
   * `prisma.submissionContest`: Exposes CRUD operations for the **SubmissionContest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionContests
    * const submissionContests = await prisma.submissionContest.findMany()
    * ```
    */
  get submissionContest(): Prisma.SubmissionContestDelegate<GlobalReject>;

  /**
   * `prisma.submissionStatistic`: Exposes CRUD operations for the **SubmissionStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionStatistics
    * const submissionStatistics = await prisma.submissionStatistic.findMany()
    * ```
    */
  get submissionStatistic(): Prisma.SubmissionStatisticDelegate<GlobalReject>;

  /**
   * `prisma.submissionContestStatistic`: Exposes CRUD operations for the **SubmissionContestStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionContestStatistics
    * const submissionContestStatistics = await prisma.submissionContestStatistic.findMany()
    * ```
    */
  get submissionContestStatistic(): Prisma.SubmissionContestStatisticDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.topicTag`: Exposes CRUD operations for the **TopicTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicTags
    * const topicTags = await prisma.topicTag.findMany()
    * ```
    */
  get topicTag(): Prisma.TopicTagDelegate<GlobalReject>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<GlobalReject>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **Status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.status.findMany()
    * ```
    */
  get status(): Prisma.StatusDelegate<GlobalReject>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<GlobalReject>;

  /**
   * `prisma.roleGroup`: Exposes CRUD operations for the **RoleGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleGroups
    * const roleGroups = await prisma.roleGroup.findMany()
    * ```
    */
  get roleGroup(): Prisma.RoleGroupDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.9.2
   * Query Engine version: 8d8414deb360336e4698a65aa45a1fbaf1ce13d8
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Domain: 'Domain',
    Post: 'Post',
    Challenge: 'Challenge',
    Submission: 'Submission',
    SubmissionContest: 'SubmissionContest',
    SubmissionStatistic: 'SubmissionStatistic',
    SubmissionContestStatistic: 'SubmissionContestStatistic',
    Category: 'Category',
    TopicTag: 'TopicTag',
    Language: 'Language',
    Status: 'Status',
    Group: 'Group',
    Role: 'Role',
    Policy: 'Policy',
    RoleGroup: 'RoleGroup'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChallengeCountOutputType
   */


  export type ChallengeCountOutputType = {
    topicTags: number
  }

  export type ChallengeCountOutputTypeSelect = {
    topicTags?: boolean
  }

  export type ChallengeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ChallengeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ChallengeCountOutputType
    : S extends undefined
    ? never
    : S extends ChallengeCountOutputTypeArgs
    ?'include' extends U
    ? ChallengeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ChallengeCountOutputType ?ChallengeCountOutputType [P]
  : 
     never
  } 
    : ChallengeCountOutputType
  : ChallengeCountOutputType




  // Custom InputTypes

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     * 
    **/
    select?: ChallengeCountOutputTypeSelect | null
  }



  /**
   * Count Type TopicTagCountOutputType
   */


  export type TopicTagCountOutputType = {
    challenges: number
  }

  export type TopicTagCountOutputTypeSelect = {
    challenges?: boolean
  }

  export type TopicTagCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TopicTagCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TopicTagCountOutputType
    : S extends undefined
    ? never
    : S extends TopicTagCountOutputTypeArgs
    ?'include' extends U
    ? TopicTagCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TopicTagCountOutputType ?TopicTagCountOutputType [P]
  : 
     never
  } 
    : TopicTagCountOutputType
  : TopicTagCountOutputType




  // Custom InputTypes

  /**
   * TopicTagCountOutputType without action
   */
  export type TopicTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TopicTagCountOutputType
     * 
    **/
    select?: TopicTagCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password: string | null
    firstname: string | null
    lastname: string | null
    status: string | null
    role: string | null
    avatar: string | null
    provider: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password: string | null
    firstname: string | null
    lastname: string | null
    status: string | null
    role: string | null
    avatar: string | null
    provider: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    firstname: number
    lastname: number
    status: number
    role: number
    avatar: number
    provider: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdByName: number
    createdAt: number
    updatedAt: number
    extendData: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstname?: true
    lastname?: true
    status?: true
    role?: true
    avatar?: true
    provider?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstname?: true
    lastname?: true
    status?: true
    role?: true
    avatar?: true
    provider?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstname?: true
    lastname?: true
    status?: true
    role?: true
    avatar?: true
    provider?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
    extendData?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    username: string
    password: string
    firstname: string
    lastname: string
    status: string
    role: string
    avatar: string | null
    provider: string
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date
    updatedAt: Date | null
    extendData: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    firstname?: boolean
    lastname?: boolean
    status?: boolean
    role?: boolean
    avatar?: boolean
    provider?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extendData?: boolean
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
     never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
  }



  /**
   * Model Domain
   */


  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type DomainSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type DomainMinAggregateOutputType = {
    id: number | null
    domain: string | null
    domainId: number | null
    status: string | null
  }

  export type DomainMaxAggregateOutputType = {
    id: number | null
    domain: string | null
    domainId: number | null
    status: string | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    domain: number
    domainId: number
    status: number
    _all: number
  }


  export type DomainAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type DomainSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type DomainMinAggregateInputType = {
    id?: true
    domain?: true
    domainId?: true
    status?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    domain?: true
    domainId?: true
    status?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    domain?: true
    domainId?: true
    status?: true
    _all?: true
  }

  export type DomainAggregateArgs = {
    /**
     * Filter which Domain to aggregate.
     * 
    **/
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs = {
    where?: DomainWhereInput
    orderBy?: Enumerable<DomainOrderByWithAggregationInput>
    by: Array<DomainScalarFieldEnum>
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _avg?: DomainAvgAggregateInputType
    _sum?: DomainSumAggregateInputType
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }


  export type DomainGroupByOutputType = {
    id: number
    domain: string
    domainId: number
    status: string
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Promise<
    Array<
      PickArray<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect = {
    id?: boolean
    domain?: boolean
    domainId?: boolean
    status?: boolean
  }

  export type DomainGetPayload<
    S extends boolean | null | undefined | DomainArgs,
    U = keyof S
      > = S extends true
        ? Domain
    : S extends undefined
    ? never
    : S extends DomainArgs | DomainFindManyArgs
    ?'include' extends U
    ? Domain 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Domain ?Domain [P]
  : 
     never
  } 
    : Domain
  : Domain


  type DomainCountArgs = Merge<
    Omit<DomainFindManyArgs, 'select' | 'include'> & {
      select?: DomainCountAggregateInputType | true
    }
  >

  export interface DomainDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DomainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DomainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Domain'> extends True ? CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>> : CheckSelect<T, Prisma__DomainClient<Domain | null >, Prisma__DomainClient<DomainGetPayload<T> | null >>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DomainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DomainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Domain'> extends True ? CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>> : CheckSelect<T, Prisma__DomainClient<Domain | null >, Prisma__DomainClient<DomainGetPayload<T> | null >>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DomainFindManyArgs>(
      args?: SelectSubset<T, DomainFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Domain>>, PrismaPromise<Array<DomainGetPayload<T>>>>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
    **/
    create<T extends DomainCreateArgs>(
      args: SelectSubset<T, DomainCreateArgs>
    ): CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>>

    /**
     * Create many Domains.
     *     @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     *     @example
     *     // Create many Domains
     *     const domain = await prisma.domain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DomainCreateManyArgs>(
      args?: SelectSubset<T, DomainCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
    **/
    delete<T extends DomainDeleteArgs>(
      args: SelectSubset<T, DomainDeleteArgs>
    ): CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DomainUpdateArgs>(
      args: SelectSubset<T, DomainUpdateArgs>
    ): CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DomainDeleteManyArgs>(
      args?: SelectSubset<T, DomainDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DomainUpdateManyArgs>(
      args: SelectSubset<T, DomainUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
    **/
    upsert<T extends DomainUpsertArgs>(
      args: SelectSubset<T, DomainUpsertArgs>
    ): CheckSelect<T, Prisma__DomainClient<Domain>, Prisma__DomainClient<DomainGetPayload<T>>>

    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DomainClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Domain findUnique
   */
  export type DomainFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * Throw an Error if a Domain can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Domain to fetch.
     * 
    **/
    where: DomainWhereUniqueInput
  }


  /**
   * Domain findFirst
   */
  export type DomainFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * Throw an Error if a Domain can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Domain to fetch.
     * 
    **/
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     * 
    **/
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     * 
    **/
    distinct?: Enumerable<DomainScalarFieldEnum>
  }


  /**
   * Domain findMany
   */
  export type DomainFindManyArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * Filter, which Domains to fetch.
     * 
    **/
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     * 
    **/
    orderBy?: Enumerable<DomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     * 
    **/
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DomainScalarFieldEnum>
  }


  /**
   * Domain create
   */
  export type DomainCreateArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * The data needed to create a Domain.
     * 
    **/
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }


  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs = {
    /**
     * The data used to create many Domains.
     * 
    **/
    data: Enumerable<DomainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Domain update
   */
  export type DomainUpdateArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * The data needed to update a Domain.
     * 
    **/
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     * 
    **/
    where: DomainWhereUniqueInput
  }


  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs = {
    /**
     * The data used to update Domains.
     * 
    **/
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     * 
    **/
    where?: DomainWhereInput
  }


  /**
   * Domain upsert
   */
  export type DomainUpsertArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * The filter to search for the Domain to update in case it exists.
     * 
    **/
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     * 
    **/
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }


  /**
   * Domain delete
   */
  export type DomainDeleteArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
    /**
     * Filter which Domain to delete.
     * 
    **/
    where: DomainWhereUniqueInput
  }


  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs = {
    /**
     * Filter which Domains to delete
     * 
    **/
    where?: DomainWhereInput
  }


  /**
   * Domain without action
   */
  export type DomainArgs = {
    /**
     * Select specific fields to fetch from the Domain
     * 
    **/
    select?: DomainSelect | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    domainId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    domainId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: number | null
    domainId: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: number | null
    domainId: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    published: number
    authorId: number
    domainId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    authorId?: true
    domainId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    authorId?: true
    domainId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
    domainId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
    domainId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
    domainId?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: Array<PostScalarFieldEnum>
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    title: string
    content: string | null
    published: boolean | null
    authorId: number | null
    domainId: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Promise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
    domainId?: boolean
  }

  export type PostGetPayload<
    S extends boolean | null | undefined | PostArgs,
    U = keyof S
      > = S extends true
        ? Post
    : S extends undefined
    ? never
    : S extends PostArgs | PostFindManyArgs
    ?'include' extends U
    ? Post 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Post ?Post [P]
  : 
     never
  } 
    : Post
  : Post


  type PostCountArgs = Merge<
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }
  >

  export interface PostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>> : CheckSelect<T, Prisma__PostClient<Post | null >, Prisma__PostClient<PostGetPayload<T> | null >>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>> : CheckSelect<T, Prisma__PostClient<Post | null >, Prisma__PostClient<PostGetPayload<T> | null >>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Post>>, PrismaPromise<Array<PostGetPayload<T>>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Throw an Error if a Post can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post findFirst
   */
  export type PostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Throw an Error if a Post can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     * 
    **/
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Filter, which Posts to fetch.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * The data needed to create a Post.
     * 
    **/
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     * 
    **/
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * The data needed to update a Post.
     * 
    **/
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     * 
    **/
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     * 
    **/
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * The filter to search for the Post to update in case it exists.
     * 
    **/
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     * 
    **/
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Filter which Post to delete.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     * 
    **/
    where?: PostWhereInput
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
  }



  /**
   * Model Challenge
   */


  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    id: number | null
    acceptedLanguages: number | null
    rate: number | null
    commentCount: number | null
    contestId: number | null
    categoryId: number | null
    companyTags: number | null
    highlightSolutionCount: number | null
    officalSolutionCount: number | null
    likes: number | null
    dislikes: number | null
    domainId: number | null
    createdById: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    id: number | null
    acceptedLanguages: number[] | null
    rate: number | null
    commentCount: number | null
    contestId: number | null
    categoryId: number | null
    companyTags: number[] | null
    highlightSolutionCount: number | null
    officalSolutionCount: number | null
    likes: number | null
    dislikes: number | null
    domainId: number | null
    createdById: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    rate: number | null
    audience: string | null
    functionName: string | null
    commentCount: number | null
    contestId: number | null
    status: string | null
    categoryId: number | null
    description: string | null
    output: string | null
    highlightSolutionCount: number | null
    isFavorited: boolean | null
    officalSolutionCount: number | null
    difficulty: string | null
    likes: number | null
    dislikes: number | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    rate: number | null
    audience: string | null
    functionName: string | null
    commentCount: number | null
    contestId: number | null
    status: string | null
    categoryId: number | null
    description: string | null
    output: string | null
    highlightSolutionCount: number | null
    isFavorited: boolean | null
    officalSolutionCount: number | null
    difficulty: string | null
    likes: number | null
    dislikes: number | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    acceptedLanguages: number
    languages: number
    rate: number
    audience: number
    functionName: number
    commentCount: number
    contestId: number
    status: number
    categoryId: number
    description: number
    companyTags: number
    contributors: number
    examples: number
    inputs: number
    structs: number
    types: number
    output: number
    highlightSolutionCount: number
    hint: number
    isFavorited: number
    officalSolutionCount: number
    testcases: number
    difficulty: number
    likes: number
    dislikes: number
    solutions: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdByName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    id?: true
    acceptedLanguages?: true
    rate?: true
    commentCount?: true
    contestId?: true
    categoryId?: true
    companyTags?: true
    highlightSolutionCount?: true
    officalSolutionCount?: true
    likes?: true
    dislikes?: true
    domainId?: true
    createdById?: true
  }

  export type ChallengeSumAggregateInputType = {
    id?: true
    acceptedLanguages?: true
    rate?: true
    commentCount?: true
    contestId?: true
    categoryId?: true
    companyTags?: true
    highlightSolutionCount?: true
    officalSolutionCount?: true
    likes?: true
    dislikes?: true
    domainId?: true
    createdById?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    rate?: true
    audience?: true
    functionName?: true
    commentCount?: true
    contestId?: true
    status?: true
    categoryId?: true
    description?: true
    output?: true
    highlightSolutionCount?: true
    isFavorited?: true
    officalSolutionCount?: true
    difficulty?: true
    likes?: true
    dislikes?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    rate?: true
    audience?: true
    functionName?: true
    commentCount?: true
    contestId?: true
    status?: true
    categoryId?: true
    description?: true
    output?: true
    highlightSolutionCount?: true
    isFavorited?: true
    officalSolutionCount?: true
    difficulty?: true
    likes?: true
    dislikes?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    acceptedLanguages?: true
    languages?: true
    rate?: true
    audience?: true
    functionName?: true
    commentCount?: true
    contestId?: true
    status?: true
    categoryId?: true
    description?: true
    companyTags?: true
    contributors?: true
    examples?: true
    inputs?: true
    structs?: true
    types?: true
    output?: true
    highlightSolutionCount?: true
    hint?: true
    isFavorited?: true
    officalSolutionCount?: true
    testcases?: true
    difficulty?: true
    likes?: true
    dislikes?: true
    solutions?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeAggregateArgs = {
    /**
     * Filter which Challenge to aggregate.
     * 
    **/
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     * 
    **/
    orderBy?: Enumerable<ChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs = {
    where?: ChallengeWhereInput
    orderBy?: Enumerable<ChallengeOrderByWithAggregationInput>
    by: Array<ChallengeScalarFieldEnum>
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }


  export type ChallengeGroupByOutputType = {
    id: number
    title: string
    slug: string
    acceptedLanguages: number[]
    languages: JsonValue | null
    rate: number | null
    audience: string
    functionName: string | null
    commentCount: number | null
    contestId: number | null
    status: string
    categoryId: number | null
    description: string | null
    companyTags: number[]
    contributors: JsonValue | null
    examples: JsonValue | null
    inputs: JsonValue | null
    structs: JsonValue | null
    types: JsonValue | null
    output: string
    highlightSolutionCount: number | null
    hint: JsonValue | null
    isFavorited: boolean
    officalSolutionCount: number | null
    testcases: JsonValue | null
    difficulty: string
    likes: number
    dislikes: number
    solutions: JsonValue | null
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Promise<
    Array<
      PickArray<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect = {
    id?: boolean
    title?: boolean
    slug?: boolean
    acceptedLanguages?: boolean
    languages?: boolean
    rate?: boolean
    audience?: boolean
    functionName?: boolean
    commentCount?: boolean
    contestId?: boolean
    status?: boolean
    categoryId?: boolean
    description?: boolean
    companyTags?: boolean
    topicTags?: boolean | TopicTagFindManyArgs
    contributors?: boolean
    examples?: boolean
    inputs?: boolean
    structs?: boolean
    types?: boolean
    output?: boolean
    highlightSolutionCount?: boolean
    hint?: boolean
    isFavorited?: boolean
    officalSolutionCount?: boolean
    testcases?: boolean
    difficulty?: boolean
    likes?: boolean
    dislikes?: boolean
    solutions?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChallengeCountOutputTypeArgs
  }

  export type ChallengeInclude = {
    topicTags?: boolean | TopicTagFindManyArgs
    _count?: boolean | ChallengeCountOutputTypeArgs
  }

  export type ChallengeGetPayload<
    S extends boolean | null | undefined | ChallengeArgs,
    U = keyof S
      > = S extends true
        ? Challenge
    : S extends undefined
    ? never
    : S extends ChallengeArgs | ChallengeFindManyArgs
    ?'include' extends U
    ? Challenge  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'topicTags'
        ? Array < TopicTagGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ChallengeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Challenge ?Challenge [P]
  : 
          P extends 'topicTags'
        ? Array < TopicTagGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ChallengeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Challenge
  : Challenge


  type ChallengeCountArgs = Merge<
    Omit<ChallengeFindManyArgs, 'select' | 'include'> & {
      select?: ChallengeCountAggregateInputType | true
    }
  >

  export interface ChallengeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChallengeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChallengeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Challenge'> extends True ? CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>> : CheckSelect<T, Prisma__ChallengeClient<Challenge | null >, Prisma__ChallengeClient<ChallengeGetPayload<T> | null >>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChallengeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChallengeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Challenge'> extends True ? CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>> : CheckSelect<T, Prisma__ChallengeClient<Challenge | null >, Prisma__ChallengeClient<ChallengeGetPayload<T> | null >>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChallengeFindManyArgs>(
      args?: SelectSubset<T, ChallengeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Challenge>>, PrismaPromise<Array<ChallengeGetPayload<T>>>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
    **/
    create<T extends ChallengeCreateArgs>(
      args: SelectSubset<T, ChallengeCreateArgs>
    ): CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>>

    /**
     * Create many Challenges.
     *     @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     *     @example
     *     // Create many Challenges
     *     const challenge = await prisma.challenge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChallengeCreateManyArgs>(
      args?: SelectSubset<T, ChallengeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
    **/
    delete<T extends ChallengeDeleteArgs>(
      args: SelectSubset<T, ChallengeDeleteArgs>
    ): CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChallengeUpdateArgs>(
      args: SelectSubset<T, ChallengeUpdateArgs>
    ): CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChallengeDeleteManyArgs>(
      args?: SelectSubset<T, ChallengeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChallengeUpdateManyArgs>(
      args: SelectSubset<T, ChallengeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
    **/
    upsert<T extends ChallengeUpsertArgs>(
      args: SelectSubset<T, ChallengeUpsertArgs>
    ): CheckSelect<T, Prisma__ChallengeClient<Challenge>, Prisma__ChallengeClient<ChallengeGetPayload<T>>>

    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChallengeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    topicTags<T extends TopicTagFindManyArgs = {}>(args?: Subset<T, TopicTagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TopicTag>>, PrismaPromise<Array<TopicTagGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * Throw an Error if a Challenge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Challenge to fetch.
     * 
    **/
    where: ChallengeWhereUniqueInput
  }


  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * Throw an Error if a Challenge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Challenge to fetch.
     * 
    **/
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     * 
    **/
    orderBy?: Enumerable<ChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     * 
    **/
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     * 
    **/
    distinct?: Enumerable<ChallengeScalarFieldEnum>
  }


  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * Filter, which Challenges to fetch.
     * 
    **/
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     * 
    **/
    orderBy?: Enumerable<ChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     * 
    **/
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChallengeScalarFieldEnum>
  }


  /**
   * Challenge create
   */
  export type ChallengeCreateArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * The data needed to create a Challenge.
     * 
    **/
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }


  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs = {
    /**
     * The data used to create many Challenges.
     * 
    **/
    data: Enumerable<ChallengeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * The data needed to update a Challenge.
     * 
    **/
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     * 
    **/
    where: ChallengeWhereUniqueInput
  }


  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs = {
    /**
     * The data used to update Challenges.
     * 
    **/
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     * 
    **/
    where?: ChallengeWhereInput
  }


  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     * 
    **/
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     * 
    **/
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }


  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
    /**
     * Filter which Challenge to delete.
     * 
    **/
    where: ChallengeWhereUniqueInput
  }


  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs = {
    /**
     * Filter which Challenges to delete
     * 
    **/
    where?: ChallengeWhereInput
  }


  /**
   * Challenge without action
   */
  export type ChallengeArgs = {
    /**
     * Select specific fields to fetch from the Challenge
     * 
    **/
    select?: ChallengeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChallengeInclude | null
  }



  /**
   * Model Submission
   */


  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    id: number | null
    challengeId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    id: number | null
    challengeId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: number | null
    languageId: string | null
    challengeId: number | null
    content: string | null
    ip: string | null
    shared: boolean | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: number | null
    languageId: string | null
    challengeId: number | null
    content: string | null
    ip: string | null
    shared: boolean | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    languageId: number
    challengeId: number
    content: number
    result: number
    info: number
    ip: number
    shared: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdAt: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    id?: true
    challengeId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionSumAggregateInputType = {
    id?: true
    challengeId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    languageId?: true
    challengeId?: true
    content?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    languageId?: true
    challengeId?: true
    content?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    languageId?: true
    challengeId?: true
    content?: true
    result?: true
    info?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
    _all?: true
  }

  export type SubmissionAggregateArgs = {
    /**
     * Filter which Submission to aggregate.
     * 
    **/
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs = {
    where?: SubmissionWhereInput
    orderBy?: Enumerable<SubmissionOrderByWithAggregationInput>
    by: Array<SubmissionScalarFieldEnum>
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }


  export type SubmissionGroupByOutputType = {
    id: number
    languageId: string | null
    challengeId: number | null
    content: string
    result: JsonValue | null
    info: JsonValue | null
    ip: string | null
    shared: boolean
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Promise<
    Array<
      PickArray<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect = {
    id?: boolean
    languageId?: boolean
    challengeId?: boolean
    content?: boolean
    result?: boolean
    info?: boolean
    ip?: boolean
    shared?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdAt?: boolean
  }

  export type SubmissionGetPayload<
    S extends boolean | null | undefined | SubmissionArgs,
    U = keyof S
      > = S extends true
        ? Submission
    : S extends undefined
    ? never
    : S extends SubmissionArgs | SubmissionFindManyArgs
    ?'include' extends U
    ? Submission 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Submission ?Submission [P]
  : 
     never
  } 
    : Submission
  : Submission


  type SubmissionCountArgs = Merge<
    Omit<SubmissionFindManyArgs, 'select' | 'include'> & {
      select?: SubmissionCountAggregateInputType | true
    }
  >

  export interface SubmissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Submission'> extends True ? CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionClient<Submission | null >, Prisma__SubmissionClient<SubmissionGetPayload<T> | null >>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Submission'> extends True ? CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionClient<Submission | null >, Prisma__SubmissionClient<SubmissionGetPayload<T> | null >>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubmissionFindManyArgs>(
      args?: SelectSubset<T, SubmissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Submission>>, PrismaPromise<Array<SubmissionGetPayload<T>>>>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
    **/
    create<T extends SubmissionCreateArgs>(
      args: SelectSubset<T, SubmissionCreateArgs>
    ): CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>>

    /**
     * Create many Submissions.
     *     @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     *     @example
     *     // Create many Submissions
     *     const submission = await prisma.submission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubmissionCreateManyArgs>(
      args?: SelectSubset<T, SubmissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
    **/
    delete<T extends SubmissionDeleteArgs>(
      args: SelectSubset<T, SubmissionDeleteArgs>
    ): CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubmissionUpdateArgs>(
      args: SelectSubset<T, SubmissionUpdateArgs>
    ): CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubmissionDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubmissionUpdateManyArgs>(
      args: SelectSubset<T, SubmissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
    **/
    upsert<T extends SubmissionUpsertArgs>(
      args: SelectSubset<T, SubmissionUpsertArgs>
    ): CheckSelect<T, Prisma__SubmissionClient<Submission>, Prisma__SubmissionClient<SubmissionGetPayload<T>>>

    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubmissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * Throw an Error if a Submission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Submission to fetch.
     * 
    **/
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * Throw an Error if a Submission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Submission to fetch.
     * 
    **/
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     * 
    **/
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     * 
    **/
    distinct?: Enumerable<SubmissionScalarFieldEnum>
  }


  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * Filter, which Submissions to fetch.
     * 
    **/
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     * 
    **/
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubmissionScalarFieldEnum>
  }


  /**
   * Submission create
   */
  export type SubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * The data needed to create a Submission.
     * 
    **/
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }


  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs = {
    /**
     * The data used to create many Submissions.
     * 
    **/
    data: Enumerable<SubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Submission update
   */
  export type SubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * The data needed to update a Submission.
     * 
    **/
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     * 
    **/
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs = {
    /**
     * The data used to update Submissions.
     * 
    **/
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     * 
    **/
    where?: SubmissionWhereInput
  }


  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * The filter to search for the Submission to update in case it exists.
     * 
    **/
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     * 
    **/
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }


  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
    /**
     * Filter which Submission to delete.
     * 
    **/
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs = {
    /**
     * Filter which Submissions to delete
     * 
    **/
    where?: SubmissionWhereInput
  }


  /**
   * Submission without action
   */
  export type SubmissionArgs = {
    /**
     * Select specific fields to fetch from the Submission
     * 
    **/
    select?: SubmissionSelect | null
  }



  /**
   * Model SubmissionContest
   */


  export type AggregateSubmissionContest = {
    _count: SubmissionContestCountAggregateOutputType | null
    _avg: SubmissionContestAvgAggregateOutputType | null
    _sum: SubmissionContestSumAggregateOutputType | null
    _min: SubmissionContestMinAggregateOutputType | null
    _max: SubmissionContestMaxAggregateOutputType | null
  }

  export type SubmissionContestAvgAggregateOutputType = {
    id: number | null
    contestId: number | null
    challengeId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestSumAggregateOutputType = {
    id: number | null
    contestId: number | null
    challengeId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestMinAggregateOutputType = {
    id: number | null
    languageId: string | null
    contestId: number | null
    challengeId: number | null
    content: string | null
    ip: string | null
    shared: boolean | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date | null
  }

  export type SubmissionContestMaxAggregateOutputType = {
    id: number | null
    languageId: string | null
    contestId: number | null
    challengeId: number | null
    content: string | null
    ip: string | null
    shared: boolean | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date | null
  }

  export type SubmissionContestCountAggregateOutputType = {
    id: number
    languageId: number
    contestId: number
    challengeId: number
    content: number
    result: number
    ip: number
    shared: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdAt: number
    _all: number
  }


  export type SubmissionContestAvgAggregateInputType = {
    id?: true
    contestId?: true
    challengeId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestSumAggregateInputType = {
    id?: true
    contestId?: true
    challengeId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestMinAggregateInputType = {
    id?: true
    languageId?: true
    contestId?: true
    challengeId?: true
    content?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
  }

  export type SubmissionContestMaxAggregateInputType = {
    id?: true
    languageId?: true
    contestId?: true
    challengeId?: true
    content?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
  }

  export type SubmissionContestCountAggregateInputType = {
    id?: true
    languageId?: true
    contestId?: true
    challengeId?: true
    content?: true
    result?: true
    ip?: true
    shared?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdAt?: true
    _all?: true
  }

  export type SubmissionContestAggregateArgs = {
    /**
     * Filter which SubmissionContest to aggregate.
     * 
    **/
    where?: SubmissionContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContests to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubmissionContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionContests
    **/
    _count?: true | SubmissionContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionContestMaxAggregateInputType
  }

  export type GetSubmissionContestAggregateType<T extends SubmissionContestAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionContest[P]>
      : GetScalarType<T[P], AggregateSubmissionContest[P]>
  }




  export type SubmissionContestGroupByArgs = {
    where?: SubmissionContestWhereInput
    orderBy?: Enumerable<SubmissionContestOrderByWithAggregationInput>
    by: Array<SubmissionContestScalarFieldEnum>
    having?: SubmissionContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionContestCountAggregateInputType | true
    _avg?: SubmissionContestAvgAggregateInputType
    _sum?: SubmissionContestSumAggregateInputType
    _min?: SubmissionContestMinAggregateInputType
    _max?: SubmissionContestMaxAggregateInputType
  }


  export type SubmissionContestGroupByOutputType = {
    id: number
    languageId: string | null
    contestId: number | null
    challengeId: number | null
    content: string
    result: JsonValue | null
    ip: string | null
    shared: boolean
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdAt: Date
    _count: SubmissionContestCountAggregateOutputType | null
    _avg: SubmissionContestAvgAggregateOutputType | null
    _sum: SubmissionContestSumAggregateOutputType | null
    _min: SubmissionContestMinAggregateOutputType | null
    _max: SubmissionContestMaxAggregateOutputType | null
  }

  type GetSubmissionContestGroupByPayload<T extends SubmissionContestGroupByArgs> = Promise<
    Array<
      PickArray<SubmissionContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionContestGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionContestGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionContestSelect = {
    id?: boolean
    languageId?: boolean
    contestId?: boolean
    challengeId?: boolean
    content?: boolean
    result?: boolean
    ip?: boolean
    shared?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdAt?: boolean
  }

  export type SubmissionContestGetPayload<
    S extends boolean | null | undefined | SubmissionContestArgs,
    U = keyof S
      > = S extends true
        ? SubmissionContest
    : S extends undefined
    ? never
    : S extends SubmissionContestArgs | SubmissionContestFindManyArgs
    ?'include' extends U
    ? SubmissionContest 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SubmissionContest ?SubmissionContest [P]
  : 
     never
  } 
    : SubmissionContest
  : SubmissionContest


  type SubmissionContestCountArgs = Merge<
    Omit<SubmissionContestFindManyArgs, 'select' | 'include'> & {
      select?: SubmissionContestCountAggregateInputType | true
    }
  >

  export interface SubmissionContestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubmissionContest that matches the filter.
     * @param {SubmissionContestFindUniqueArgs} args - Arguments to find a SubmissionContest
     * @example
     * // Get one SubmissionContest
     * const submissionContest = await prisma.submissionContest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubmissionContestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubmissionContestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubmissionContest'> extends True ? CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest | null >, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T> | null >>

    /**
     * Find the first SubmissionContest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestFindFirstArgs} args - Arguments to find a SubmissionContest
     * @example
     * // Get one SubmissionContest
     * const submissionContest = await prisma.submissionContest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubmissionContestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubmissionContestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubmissionContest'> extends True ? CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest | null >, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T> | null >>

    /**
     * Find zero or more SubmissionContests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionContests
     * const submissionContests = await prisma.submissionContest.findMany()
     * 
     * // Get first 10 SubmissionContests
     * const submissionContests = await prisma.submissionContest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionContestWithIdOnly = await prisma.submissionContest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubmissionContestFindManyArgs>(
      args?: SelectSubset<T, SubmissionContestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubmissionContest>>, PrismaPromise<Array<SubmissionContestGetPayload<T>>>>

    /**
     * Create a SubmissionContest.
     * @param {SubmissionContestCreateArgs} args - Arguments to create a SubmissionContest.
     * @example
     * // Create one SubmissionContest
     * const SubmissionContest = await prisma.submissionContest.create({
     *   data: {
     *     // ... data to create a SubmissionContest
     *   }
     * })
     * 
    **/
    create<T extends SubmissionContestCreateArgs>(
      args: SelectSubset<T, SubmissionContestCreateArgs>
    ): CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>>

    /**
     * Create many SubmissionContests.
     *     @param {SubmissionContestCreateManyArgs} args - Arguments to create many SubmissionContests.
     *     @example
     *     // Create many SubmissionContests
     *     const submissionContest = await prisma.submissionContest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubmissionContestCreateManyArgs>(
      args?: SelectSubset<T, SubmissionContestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubmissionContest.
     * @param {SubmissionContestDeleteArgs} args - Arguments to delete one SubmissionContest.
     * @example
     * // Delete one SubmissionContest
     * const SubmissionContest = await prisma.submissionContest.delete({
     *   where: {
     *     // ... filter to delete one SubmissionContest
     *   }
     * })
     * 
    **/
    delete<T extends SubmissionContestDeleteArgs>(
      args: SelectSubset<T, SubmissionContestDeleteArgs>
    ): CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>>

    /**
     * Update one SubmissionContest.
     * @param {SubmissionContestUpdateArgs} args - Arguments to update one SubmissionContest.
     * @example
     * // Update one SubmissionContest
     * const submissionContest = await prisma.submissionContest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubmissionContestUpdateArgs>(
      args: SelectSubset<T, SubmissionContestUpdateArgs>
    ): CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>>

    /**
     * Delete zero or more SubmissionContests.
     * @param {SubmissionContestDeleteManyArgs} args - Arguments to filter SubmissionContests to delete.
     * @example
     * // Delete a few SubmissionContests
     * const { count } = await prisma.submissionContest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubmissionContestDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionContestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionContests
     * const submissionContest = await prisma.submissionContest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubmissionContestUpdateManyArgs>(
      args: SelectSubset<T, SubmissionContestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubmissionContest.
     * @param {SubmissionContestUpsertArgs} args - Arguments to update or create a SubmissionContest.
     * @example
     * // Update or create a SubmissionContest
     * const submissionContest = await prisma.submissionContest.upsert({
     *   create: {
     *     // ... data to create a SubmissionContest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionContest we want to update
     *   }
     * })
    **/
    upsert<T extends SubmissionContestUpsertArgs>(
      args: SelectSubset<T, SubmissionContestUpsertArgs>
    ): CheckSelect<T, Prisma__SubmissionContestClient<SubmissionContest>, Prisma__SubmissionContestClient<SubmissionContestGetPayload<T>>>

    /**
     * Count the number of SubmissionContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestCountArgs} args - Arguments to filter SubmissionContests to count.
     * @example
     * // Count the number of SubmissionContests
     * const count = await prisma.submissionContest.count({
     *   where: {
     *     // ... the filter for the SubmissionContests we want to count
     *   }
     * })
    **/
    count<T extends SubmissionContestCountArgs>(
      args?: Subset<T, SubmissionContestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionContestAggregateArgs>(args: Subset<T, SubmissionContestAggregateArgs>): PrismaPromise<GetSubmissionContestAggregateType<T>>

    /**
     * Group by SubmissionContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionContestGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionContestGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionContest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubmissionContestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubmissionContest findUnique
   */
  export type SubmissionContestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * Throw an Error if a SubmissionContest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionContest to fetch.
     * 
    **/
    where: SubmissionContestWhereUniqueInput
  }


  /**
   * SubmissionContest findFirst
   */
  export type SubmissionContestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * Throw an Error if a SubmissionContest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionContest to fetch.
     * 
    **/
    where?: SubmissionContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContests to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionContests.
     * 
    **/
    cursor?: SubmissionContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionContests.
     * 
    **/
    distinct?: Enumerable<SubmissionContestScalarFieldEnum>
  }


  /**
   * SubmissionContest findMany
   */
  export type SubmissionContestFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * Filter, which SubmissionContests to fetch.
     * 
    **/
    where?: SubmissionContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContests to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionContests.
     * 
    **/
    cursor?: SubmissionContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubmissionContestScalarFieldEnum>
  }


  /**
   * SubmissionContest create
   */
  export type SubmissionContestCreateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * The data needed to create a SubmissionContest.
     * 
    **/
    data: XOR<SubmissionContestCreateInput, SubmissionContestUncheckedCreateInput>
  }


  /**
   * SubmissionContest createMany
   */
  export type SubmissionContestCreateManyArgs = {
    /**
     * The data used to create many SubmissionContests.
     * 
    **/
    data: Enumerable<SubmissionContestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubmissionContest update
   */
  export type SubmissionContestUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * The data needed to update a SubmissionContest.
     * 
    **/
    data: XOR<SubmissionContestUpdateInput, SubmissionContestUncheckedUpdateInput>
    /**
     * Choose, which SubmissionContest to update.
     * 
    **/
    where: SubmissionContestWhereUniqueInput
  }


  /**
   * SubmissionContest updateMany
   */
  export type SubmissionContestUpdateManyArgs = {
    /**
     * The data used to update SubmissionContests.
     * 
    **/
    data: XOR<SubmissionContestUpdateManyMutationInput, SubmissionContestUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionContests to update
     * 
    **/
    where?: SubmissionContestWhereInput
  }


  /**
   * SubmissionContest upsert
   */
  export type SubmissionContestUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * The filter to search for the SubmissionContest to update in case it exists.
     * 
    **/
    where: SubmissionContestWhereUniqueInput
    /**
     * In case the SubmissionContest found by the `where` argument doesn't exist, create a new SubmissionContest with this data.
     * 
    **/
    create: XOR<SubmissionContestCreateInput, SubmissionContestUncheckedCreateInput>
    /**
     * In case the SubmissionContest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubmissionContestUpdateInput, SubmissionContestUncheckedUpdateInput>
  }


  /**
   * SubmissionContest delete
   */
  export type SubmissionContestDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
    /**
     * Filter which SubmissionContest to delete.
     * 
    **/
    where: SubmissionContestWhereUniqueInput
  }


  /**
   * SubmissionContest deleteMany
   */
  export type SubmissionContestDeleteManyArgs = {
    /**
     * Filter which SubmissionContests to delete
     * 
    **/
    where?: SubmissionContestWhereInput
  }


  /**
   * SubmissionContest without action
   */
  export type SubmissionContestArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContest
     * 
    **/
    select?: SubmissionContestSelect | null
  }



  /**
   * Model SubmissionStatistic
   */


  export type AggregateSubmissionStatistic = {
    _count: SubmissionStatisticCountAggregateOutputType | null
    _avg: SubmissionStatisticAvgAggregateOutputType | null
    _sum: SubmissionStatisticSumAggregateOutputType | null
    _min: SubmissionStatisticMinAggregateOutputType | null
    _max: SubmissionStatisticMaxAggregateOutputType | null
  }

  export type SubmissionStatisticAvgAggregateOutputType = {
    id: number | null
    challengeId: number | null
    score: number | null
    submitCount: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionStatisticSumAggregateOutputType = {
    id: number | null
    challengeId: number | null
    score: number | null
    submitCount: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionStatisticMinAggregateOutputType = {
    id: number | null
    challengeId: number | null
    languageId: string | null
    score: number | null
    submitCount: number | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    lastSubmitTime: Date | null
  }

  export type SubmissionStatisticMaxAggregateOutputType = {
    id: number | null
    challengeId: number | null
    languageId: string | null
    score: number | null
    submitCount: number | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    lastSubmitTime: Date | null
  }

  export type SubmissionStatisticCountAggregateOutputType = {
    id: number
    challengeId: number
    languageId: number
    score: number
    submitCount: number
    info: number
    domainId: number
    createdById: number
    createdByUsername: number
    lastSubmitTime: number
    _all: number
  }


  export type SubmissionStatisticAvgAggregateInputType = {
    id?: true
    challengeId?: true
    score?: true
    submitCount?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionStatisticSumAggregateInputType = {
    id?: true
    challengeId?: true
    score?: true
    submitCount?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionStatisticMinAggregateInputType = {
    id?: true
    challengeId?: true
    languageId?: true
    score?: true
    submitCount?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    lastSubmitTime?: true
  }

  export type SubmissionStatisticMaxAggregateInputType = {
    id?: true
    challengeId?: true
    languageId?: true
    score?: true
    submitCount?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    lastSubmitTime?: true
  }

  export type SubmissionStatisticCountAggregateInputType = {
    id?: true
    challengeId?: true
    languageId?: true
    score?: true
    submitCount?: true
    info?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    lastSubmitTime?: true
    _all?: true
  }

  export type SubmissionStatisticAggregateArgs = {
    /**
     * Filter which SubmissionStatistic to aggregate.
     * 
    **/
    where?: SubmissionStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubmissionStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionStatistics
    **/
    _count?: true | SubmissionStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionStatisticMaxAggregateInputType
  }

  export type GetSubmissionStatisticAggregateType<T extends SubmissionStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionStatistic[P]>
      : GetScalarType<T[P], AggregateSubmissionStatistic[P]>
  }




  export type SubmissionStatisticGroupByArgs = {
    where?: SubmissionStatisticWhereInput
    orderBy?: Enumerable<SubmissionStatisticOrderByWithAggregationInput>
    by: Array<SubmissionStatisticScalarFieldEnum>
    having?: SubmissionStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionStatisticCountAggregateInputType | true
    _avg?: SubmissionStatisticAvgAggregateInputType
    _sum?: SubmissionStatisticSumAggregateInputType
    _min?: SubmissionStatisticMinAggregateInputType
    _max?: SubmissionStatisticMaxAggregateInputType
  }


  export type SubmissionStatisticGroupByOutputType = {
    id: number
    challengeId: number | null
    languageId: string | null
    score: number
    submitCount: number
    info: JsonValue | null
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    lastSubmitTime: Date
    _count: SubmissionStatisticCountAggregateOutputType | null
    _avg: SubmissionStatisticAvgAggregateOutputType | null
    _sum: SubmissionStatisticSumAggregateOutputType | null
    _min: SubmissionStatisticMinAggregateOutputType | null
    _max: SubmissionStatisticMaxAggregateOutputType | null
  }

  type GetSubmissionStatisticGroupByPayload<T extends SubmissionStatisticGroupByArgs> = Promise<
    Array<
      PickArray<SubmissionStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionStatisticGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionStatisticSelect = {
    id?: boolean
    challengeId?: boolean
    languageId?: boolean
    score?: boolean
    submitCount?: boolean
    info?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    lastSubmitTime?: boolean
  }

  export type SubmissionStatisticGetPayload<
    S extends boolean | null | undefined | SubmissionStatisticArgs,
    U = keyof S
      > = S extends true
        ? SubmissionStatistic
    : S extends undefined
    ? never
    : S extends SubmissionStatisticArgs | SubmissionStatisticFindManyArgs
    ?'include' extends U
    ? SubmissionStatistic 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SubmissionStatistic ?SubmissionStatistic [P]
  : 
     never
  } 
    : SubmissionStatistic
  : SubmissionStatistic


  type SubmissionStatisticCountArgs = Merge<
    Omit<SubmissionStatisticFindManyArgs, 'select' | 'include'> & {
      select?: SubmissionStatisticCountAggregateInputType | true
    }
  >

  export interface SubmissionStatisticDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubmissionStatistic that matches the filter.
     * @param {SubmissionStatisticFindUniqueArgs} args - Arguments to find a SubmissionStatistic
     * @example
     * // Get one SubmissionStatistic
     * const submissionStatistic = await prisma.submissionStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubmissionStatisticFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubmissionStatisticFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubmissionStatistic'> extends True ? CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic | null >, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T> | null >>

    /**
     * Find the first SubmissionStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticFindFirstArgs} args - Arguments to find a SubmissionStatistic
     * @example
     * // Get one SubmissionStatistic
     * const submissionStatistic = await prisma.submissionStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubmissionStatisticFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubmissionStatisticFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubmissionStatistic'> extends True ? CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic | null >, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T> | null >>

    /**
     * Find zero or more SubmissionStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionStatistics
     * const submissionStatistics = await prisma.submissionStatistic.findMany()
     * 
     * // Get first 10 SubmissionStatistics
     * const submissionStatistics = await prisma.submissionStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionStatisticWithIdOnly = await prisma.submissionStatistic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubmissionStatisticFindManyArgs>(
      args?: SelectSubset<T, SubmissionStatisticFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubmissionStatistic>>, PrismaPromise<Array<SubmissionStatisticGetPayload<T>>>>

    /**
     * Create a SubmissionStatistic.
     * @param {SubmissionStatisticCreateArgs} args - Arguments to create a SubmissionStatistic.
     * @example
     * // Create one SubmissionStatistic
     * const SubmissionStatistic = await prisma.submissionStatistic.create({
     *   data: {
     *     // ... data to create a SubmissionStatistic
     *   }
     * })
     * 
    **/
    create<T extends SubmissionStatisticCreateArgs>(
      args: SelectSubset<T, SubmissionStatisticCreateArgs>
    ): CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>>

    /**
     * Create many SubmissionStatistics.
     *     @param {SubmissionStatisticCreateManyArgs} args - Arguments to create many SubmissionStatistics.
     *     @example
     *     // Create many SubmissionStatistics
     *     const submissionStatistic = await prisma.submissionStatistic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubmissionStatisticCreateManyArgs>(
      args?: SelectSubset<T, SubmissionStatisticCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubmissionStatistic.
     * @param {SubmissionStatisticDeleteArgs} args - Arguments to delete one SubmissionStatistic.
     * @example
     * // Delete one SubmissionStatistic
     * const SubmissionStatistic = await prisma.submissionStatistic.delete({
     *   where: {
     *     // ... filter to delete one SubmissionStatistic
     *   }
     * })
     * 
    **/
    delete<T extends SubmissionStatisticDeleteArgs>(
      args: SelectSubset<T, SubmissionStatisticDeleteArgs>
    ): CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>>

    /**
     * Update one SubmissionStatistic.
     * @param {SubmissionStatisticUpdateArgs} args - Arguments to update one SubmissionStatistic.
     * @example
     * // Update one SubmissionStatistic
     * const submissionStatistic = await prisma.submissionStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubmissionStatisticUpdateArgs>(
      args: SelectSubset<T, SubmissionStatisticUpdateArgs>
    ): CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>>

    /**
     * Delete zero or more SubmissionStatistics.
     * @param {SubmissionStatisticDeleteManyArgs} args - Arguments to filter SubmissionStatistics to delete.
     * @example
     * // Delete a few SubmissionStatistics
     * const { count } = await prisma.submissionStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubmissionStatisticDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionStatisticDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionStatistics
     * const submissionStatistic = await prisma.submissionStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubmissionStatisticUpdateManyArgs>(
      args: SelectSubset<T, SubmissionStatisticUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubmissionStatistic.
     * @param {SubmissionStatisticUpsertArgs} args - Arguments to update or create a SubmissionStatistic.
     * @example
     * // Update or create a SubmissionStatistic
     * const submissionStatistic = await prisma.submissionStatistic.upsert({
     *   create: {
     *     // ... data to create a SubmissionStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionStatistic we want to update
     *   }
     * })
    **/
    upsert<T extends SubmissionStatisticUpsertArgs>(
      args: SelectSubset<T, SubmissionStatisticUpsertArgs>
    ): CheckSelect<T, Prisma__SubmissionStatisticClient<SubmissionStatistic>, Prisma__SubmissionStatisticClient<SubmissionStatisticGetPayload<T>>>

    /**
     * Count the number of SubmissionStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticCountArgs} args - Arguments to filter SubmissionStatistics to count.
     * @example
     * // Count the number of SubmissionStatistics
     * const count = await prisma.submissionStatistic.count({
     *   where: {
     *     // ... the filter for the SubmissionStatistics we want to count
     *   }
     * })
    **/
    count<T extends SubmissionStatisticCountArgs>(
      args?: Subset<T, SubmissionStatisticCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionStatisticAggregateArgs>(args: Subset<T, SubmissionStatisticAggregateArgs>): PrismaPromise<GetSubmissionStatisticAggregateType<T>>

    /**
     * Group by SubmissionStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionStatisticGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionStatisticGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubmissionStatisticClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubmissionStatistic findUnique
   */
  export type SubmissionStatisticFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * Throw an Error if a SubmissionStatistic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionStatistic to fetch.
     * 
    **/
    where: SubmissionStatisticWhereUniqueInput
  }


  /**
   * SubmissionStatistic findFirst
   */
  export type SubmissionStatisticFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * Throw an Error if a SubmissionStatistic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionStatistic to fetch.
     * 
    **/
    where?: SubmissionStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionStatistics.
     * 
    **/
    cursor?: SubmissionStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionStatistics.
     * 
    **/
    distinct?: Enumerable<SubmissionStatisticScalarFieldEnum>
  }


  /**
   * SubmissionStatistic findMany
   */
  export type SubmissionStatisticFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * Filter, which SubmissionStatistics to fetch.
     * 
    **/
    where?: SubmissionStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionStatistics.
     * 
    **/
    cursor?: SubmissionStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionStatistics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubmissionStatisticScalarFieldEnum>
  }


  /**
   * SubmissionStatistic create
   */
  export type SubmissionStatisticCreateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * The data needed to create a SubmissionStatistic.
     * 
    **/
    data: XOR<SubmissionStatisticCreateInput, SubmissionStatisticUncheckedCreateInput>
  }


  /**
   * SubmissionStatistic createMany
   */
  export type SubmissionStatisticCreateManyArgs = {
    /**
     * The data used to create many SubmissionStatistics.
     * 
    **/
    data: Enumerable<SubmissionStatisticCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubmissionStatistic update
   */
  export type SubmissionStatisticUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * The data needed to update a SubmissionStatistic.
     * 
    **/
    data: XOR<SubmissionStatisticUpdateInput, SubmissionStatisticUncheckedUpdateInput>
    /**
     * Choose, which SubmissionStatistic to update.
     * 
    **/
    where: SubmissionStatisticWhereUniqueInput
  }


  /**
   * SubmissionStatistic updateMany
   */
  export type SubmissionStatisticUpdateManyArgs = {
    /**
     * The data used to update SubmissionStatistics.
     * 
    **/
    data: XOR<SubmissionStatisticUpdateManyMutationInput, SubmissionStatisticUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionStatistics to update
     * 
    **/
    where?: SubmissionStatisticWhereInput
  }


  /**
   * SubmissionStatistic upsert
   */
  export type SubmissionStatisticUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * The filter to search for the SubmissionStatistic to update in case it exists.
     * 
    **/
    where: SubmissionStatisticWhereUniqueInput
    /**
     * In case the SubmissionStatistic found by the `where` argument doesn't exist, create a new SubmissionStatistic with this data.
     * 
    **/
    create: XOR<SubmissionStatisticCreateInput, SubmissionStatisticUncheckedCreateInput>
    /**
     * In case the SubmissionStatistic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubmissionStatisticUpdateInput, SubmissionStatisticUncheckedUpdateInput>
  }


  /**
   * SubmissionStatistic delete
   */
  export type SubmissionStatisticDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
    /**
     * Filter which SubmissionStatistic to delete.
     * 
    **/
    where: SubmissionStatisticWhereUniqueInput
  }


  /**
   * SubmissionStatistic deleteMany
   */
  export type SubmissionStatisticDeleteManyArgs = {
    /**
     * Filter which SubmissionStatistics to delete
     * 
    **/
    where?: SubmissionStatisticWhereInput
  }


  /**
   * SubmissionStatistic without action
   */
  export type SubmissionStatisticArgs = {
    /**
     * Select specific fields to fetch from the SubmissionStatistic
     * 
    **/
    select?: SubmissionStatisticSelect | null
  }



  /**
   * Model SubmissionContestStatistic
   */


  export type AggregateSubmissionContestStatistic = {
    _count: SubmissionContestStatisticCountAggregateOutputType | null
    _avg: SubmissionContestStatisticAvgAggregateOutputType | null
    _sum: SubmissionContestStatisticSumAggregateOutputType | null
    _min: SubmissionContestStatisticMinAggregateOutputType | null
    _max: SubmissionContestStatisticMaxAggregateOutputType | null
  }

  export type SubmissionContestStatisticAvgAggregateOutputType = {
    id: number | null
    contestId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestStatisticSumAggregateOutputType = {
    id: number | null
    contestId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestStatisticMinAggregateOutputType = {
    id: number | null
    contestId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestStatisticMaxAggregateOutputType = {
    id: number | null
    contestId: number | null
    domainId: number | null
    createdById: number | null
  }

  export type SubmissionContestStatisticCountAggregateOutputType = {
    id: number
    contestId: number
    info: number
    domainId: number
    createdById: number
    _all: number
  }


  export type SubmissionContestStatisticAvgAggregateInputType = {
    id?: true
    contestId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestStatisticSumAggregateInputType = {
    id?: true
    contestId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestStatisticMinAggregateInputType = {
    id?: true
    contestId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestStatisticMaxAggregateInputType = {
    id?: true
    contestId?: true
    domainId?: true
    createdById?: true
  }

  export type SubmissionContestStatisticCountAggregateInputType = {
    id?: true
    contestId?: true
    info?: true
    domainId?: true
    createdById?: true
    _all?: true
  }

  export type SubmissionContestStatisticAggregateArgs = {
    /**
     * Filter which SubmissionContestStatistic to aggregate.
     * 
    **/
    where?: SubmissionContestStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContestStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubmissionContestStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContestStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContestStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionContestStatistics
    **/
    _count?: true | SubmissionContestStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionContestStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionContestStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionContestStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionContestStatisticMaxAggregateInputType
  }

  export type GetSubmissionContestStatisticAggregateType<T extends SubmissionContestStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionContestStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionContestStatistic[P]>
      : GetScalarType<T[P], AggregateSubmissionContestStatistic[P]>
  }




  export type SubmissionContestStatisticGroupByArgs = {
    where?: SubmissionContestStatisticWhereInput
    orderBy?: Enumerable<SubmissionContestStatisticOrderByWithAggregationInput>
    by: Array<SubmissionContestStatisticScalarFieldEnum>
    having?: SubmissionContestStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionContestStatisticCountAggregateInputType | true
    _avg?: SubmissionContestStatisticAvgAggregateInputType
    _sum?: SubmissionContestStatisticSumAggregateInputType
    _min?: SubmissionContestStatisticMinAggregateInputType
    _max?: SubmissionContestStatisticMaxAggregateInputType
  }


  export type SubmissionContestStatisticGroupByOutputType = {
    id: number
    contestId: number | null
    info: JsonValue | null
    domainId: number
    createdById: number | null
    _count: SubmissionContestStatisticCountAggregateOutputType | null
    _avg: SubmissionContestStatisticAvgAggregateOutputType | null
    _sum: SubmissionContestStatisticSumAggregateOutputType | null
    _min: SubmissionContestStatisticMinAggregateOutputType | null
    _max: SubmissionContestStatisticMaxAggregateOutputType | null
  }

  type GetSubmissionContestStatisticGroupByPayload<T extends SubmissionContestStatisticGroupByArgs> = Promise<
    Array<
      PickArray<SubmissionContestStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionContestStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionContestStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionContestStatisticGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionContestStatisticSelect = {
    id?: boolean
    contestId?: boolean
    info?: boolean
    domainId?: boolean
    createdById?: boolean
  }

  export type SubmissionContestStatisticGetPayload<
    S extends boolean | null | undefined | SubmissionContestStatisticArgs,
    U = keyof S
      > = S extends true
        ? SubmissionContestStatistic
    : S extends undefined
    ? never
    : S extends SubmissionContestStatisticArgs | SubmissionContestStatisticFindManyArgs
    ?'include' extends U
    ? SubmissionContestStatistic 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SubmissionContestStatistic ?SubmissionContestStatistic [P]
  : 
     never
  } 
    : SubmissionContestStatistic
  : SubmissionContestStatistic


  type SubmissionContestStatisticCountArgs = Merge<
    Omit<SubmissionContestStatisticFindManyArgs, 'select' | 'include'> & {
      select?: SubmissionContestStatisticCountAggregateInputType | true
    }
  >

  export interface SubmissionContestStatisticDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubmissionContestStatistic that matches the filter.
     * @param {SubmissionContestStatisticFindUniqueArgs} args - Arguments to find a SubmissionContestStatistic
     * @example
     * // Get one SubmissionContestStatistic
     * const submissionContestStatistic = await prisma.submissionContestStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubmissionContestStatisticFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubmissionContestStatisticFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubmissionContestStatistic'> extends True ? CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic | null >, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T> | null >>

    /**
     * Find the first SubmissionContestStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticFindFirstArgs} args - Arguments to find a SubmissionContestStatistic
     * @example
     * // Get one SubmissionContestStatistic
     * const submissionContestStatistic = await prisma.submissionContestStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubmissionContestStatisticFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubmissionContestStatisticFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubmissionContestStatistic'> extends True ? CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>> : CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic | null >, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T> | null >>

    /**
     * Find zero or more SubmissionContestStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionContestStatistics
     * const submissionContestStatistics = await prisma.submissionContestStatistic.findMany()
     * 
     * // Get first 10 SubmissionContestStatistics
     * const submissionContestStatistics = await prisma.submissionContestStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionContestStatisticWithIdOnly = await prisma.submissionContestStatistic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubmissionContestStatisticFindManyArgs>(
      args?: SelectSubset<T, SubmissionContestStatisticFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubmissionContestStatistic>>, PrismaPromise<Array<SubmissionContestStatisticGetPayload<T>>>>

    /**
     * Create a SubmissionContestStatistic.
     * @param {SubmissionContestStatisticCreateArgs} args - Arguments to create a SubmissionContestStatistic.
     * @example
     * // Create one SubmissionContestStatistic
     * const SubmissionContestStatistic = await prisma.submissionContestStatistic.create({
     *   data: {
     *     // ... data to create a SubmissionContestStatistic
     *   }
     * })
     * 
    **/
    create<T extends SubmissionContestStatisticCreateArgs>(
      args: SelectSubset<T, SubmissionContestStatisticCreateArgs>
    ): CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>>

    /**
     * Create many SubmissionContestStatistics.
     *     @param {SubmissionContestStatisticCreateManyArgs} args - Arguments to create many SubmissionContestStatistics.
     *     @example
     *     // Create many SubmissionContestStatistics
     *     const submissionContestStatistic = await prisma.submissionContestStatistic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubmissionContestStatisticCreateManyArgs>(
      args?: SelectSubset<T, SubmissionContestStatisticCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubmissionContestStatistic.
     * @param {SubmissionContestStatisticDeleteArgs} args - Arguments to delete one SubmissionContestStatistic.
     * @example
     * // Delete one SubmissionContestStatistic
     * const SubmissionContestStatistic = await prisma.submissionContestStatistic.delete({
     *   where: {
     *     // ... filter to delete one SubmissionContestStatistic
     *   }
     * })
     * 
    **/
    delete<T extends SubmissionContestStatisticDeleteArgs>(
      args: SelectSubset<T, SubmissionContestStatisticDeleteArgs>
    ): CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>>

    /**
     * Update one SubmissionContestStatistic.
     * @param {SubmissionContestStatisticUpdateArgs} args - Arguments to update one SubmissionContestStatistic.
     * @example
     * // Update one SubmissionContestStatistic
     * const submissionContestStatistic = await prisma.submissionContestStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubmissionContestStatisticUpdateArgs>(
      args: SelectSubset<T, SubmissionContestStatisticUpdateArgs>
    ): CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>>

    /**
     * Delete zero or more SubmissionContestStatistics.
     * @param {SubmissionContestStatisticDeleteManyArgs} args - Arguments to filter SubmissionContestStatistics to delete.
     * @example
     * // Delete a few SubmissionContestStatistics
     * const { count } = await prisma.submissionContestStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubmissionContestStatisticDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionContestStatisticDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionContestStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionContestStatistics
     * const submissionContestStatistic = await prisma.submissionContestStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubmissionContestStatisticUpdateManyArgs>(
      args: SelectSubset<T, SubmissionContestStatisticUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubmissionContestStatistic.
     * @param {SubmissionContestStatisticUpsertArgs} args - Arguments to update or create a SubmissionContestStatistic.
     * @example
     * // Update or create a SubmissionContestStatistic
     * const submissionContestStatistic = await prisma.submissionContestStatistic.upsert({
     *   create: {
     *     // ... data to create a SubmissionContestStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionContestStatistic we want to update
     *   }
     * })
    **/
    upsert<T extends SubmissionContestStatisticUpsertArgs>(
      args: SelectSubset<T, SubmissionContestStatisticUpsertArgs>
    ): CheckSelect<T, Prisma__SubmissionContestStatisticClient<SubmissionContestStatistic>, Prisma__SubmissionContestStatisticClient<SubmissionContestStatisticGetPayload<T>>>

    /**
     * Count the number of SubmissionContestStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticCountArgs} args - Arguments to filter SubmissionContestStatistics to count.
     * @example
     * // Count the number of SubmissionContestStatistics
     * const count = await prisma.submissionContestStatistic.count({
     *   where: {
     *     // ... the filter for the SubmissionContestStatistics we want to count
     *   }
     * })
    **/
    count<T extends SubmissionContestStatisticCountArgs>(
      args?: Subset<T, SubmissionContestStatisticCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionContestStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionContestStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionContestStatisticAggregateArgs>(args: Subset<T, SubmissionContestStatisticAggregateArgs>): PrismaPromise<GetSubmissionContestStatisticAggregateType<T>>

    /**
     * Group by SubmissionContestStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionContestStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionContestStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionContestStatisticGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionContestStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionContestStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionContestStatisticGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionContestStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubmissionContestStatisticClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubmissionContestStatistic findUnique
   */
  export type SubmissionContestStatisticFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * Throw an Error if a SubmissionContestStatistic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionContestStatistic to fetch.
     * 
    **/
    where: SubmissionContestStatisticWhereUniqueInput
  }


  /**
   * SubmissionContestStatistic findFirst
   */
  export type SubmissionContestStatisticFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * Throw an Error if a SubmissionContestStatistic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubmissionContestStatistic to fetch.
     * 
    **/
    where?: SubmissionContestStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContestStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionContestStatistics.
     * 
    **/
    cursor?: SubmissionContestStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContestStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContestStatistics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionContestStatistics.
     * 
    **/
    distinct?: Enumerable<SubmissionContestStatisticScalarFieldEnum>
  }


  /**
   * SubmissionContestStatistic findMany
   */
  export type SubmissionContestStatisticFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * Filter, which SubmissionContestStatistics to fetch.
     * 
    **/
    where?: SubmissionContestStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionContestStatistics to fetch.
     * 
    **/
    orderBy?: Enumerable<SubmissionContestStatisticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionContestStatistics.
     * 
    **/
    cursor?: SubmissionContestStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionContestStatistics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionContestStatistics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubmissionContestStatisticScalarFieldEnum>
  }


  /**
   * SubmissionContestStatistic create
   */
  export type SubmissionContestStatisticCreateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * The data needed to create a SubmissionContestStatistic.
     * 
    **/
    data: XOR<SubmissionContestStatisticCreateInput, SubmissionContestStatisticUncheckedCreateInput>
  }


  /**
   * SubmissionContestStatistic createMany
   */
  export type SubmissionContestStatisticCreateManyArgs = {
    /**
     * The data used to create many SubmissionContestStatistics.
     * 
    **/
    data: Enumerable<SubmissionContestStatisticCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubmissionContestStatistic update
   */
  export type SubmissionContestStatisticUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * The data needed to update a SubmissionContestStatistic.
     * 
    **/
    data: XOR<SubmissionContestStatisticUpdateInput, SubmissionContestStatisticUncheckedUpdateInput>
    /**
     * Choose, which SubmissionContestStatistic to update.
     * 
    **/
    where: SubmissionContestStatisticWhereUniqueInput
  }


  /**
   * SubmissionContestStatistic updateMany
   */
  export type SubmissionContestStatisticUpdateManyArgs = {
    /**
     * The data used to update SubmissionContestStatistics.
     * 
    **/
    data: XOR<SubmissionContestStatisticUpdateManyMutationInput, SubmissionContestStatisticUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionContestStatistics to update
     * 
    **/
    where?: SubmissionContestStatisticWhereInput
  }


  /**
   * SubmissionContestStatistic upsert
   */
  export type SubmissionContestStatisticUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * The filter to search for the SubmissionContestStatistic to update in case it exists.
     * 
    **/
    where: SubmissionContestStatisticWhereUniqueInput
    /**
     * In case the SubmissionContestStatistic found by the `where` argument doesn't exist, create a new SubmissionContestStatistic with this data.
     * 
    **/
    create: XOR<SubmissionContestStatisticCreateInput, SubmissionContestStatisticUncheckedCreateInput>
    /**
     * In case the SubmissionContestStatistic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubmissionContestStatisticUpdateInput, SubmissionContestStatisticUncheckedUpdateInput>
  }


  /**
   * SubmissionContestStatistic delete
   */
  export type SubmissionContestStatisticDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
    /**
     * Filter which SubmissionContestStatistic to delete.
     * 
    **/
    where: SubmissionContestStatisticWhereUniqueInput
  }


  /**
   * SubmissionContestStatistic deleteMany
   */
  export type SubmissionContestStatisticDeleteManyArgs = {
    /**
     * Filter which SubmissionContestStatistics to delete
     * 
    **/
    where?: SubmissionContestStatisticWhereInput
  }


  /**
   * SubmissionContestStatistic without action
   */
  export type SubmissionContestStatisticArgs = {
    /**
     * Select specific fields to fetch from the SubmissionContestStatistic
     * 
    **/
    select?: SubmissionContestStatisticSelect | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    status: string | null
    domainId: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    status: string | null
    domainId: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    status: number
    domainId: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    slug: string
    status: string
    domainId: number
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Promise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    status?: boolean
    domainId?: boolean
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Category ?Category [P]
  : 
     never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
  }



  /**
   * Model TopicTag
   */


  export type AggregateTopicTag = {
    _count: TopicTagCountAggregateOutputType | null
    _avg: TopicTagAvgAggregateOutputType | null
    _sum: TopicTagSumAggregateOutputType | null
    _min: TopicTagMinAggregateOutputType | null
    _max: TopicTagMaxAggregateOutputType | null
  }

  export type TopicTagAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type TopicTagSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type TopicTagMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    status: string | null
    domainId: number | null
  }

  export type TopicTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    status: string | null
    domainId: number | null
  }

  export type TopicTagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    status: number
    domainId: number
    _all: number
  }


  export type TopicTagAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type TopicTagSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type TopicTagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
  }

  export type TopicTagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
  }

  export type TopicTagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    status?: true
    domainId?: true
    _all?: true
  }

  export type TopicTagAggregateArgs = {
    /**
     * Filter which TopicTag to aggregate.
     * 
    **/
    where?: TopicTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicTags to fetch.
     * 
    **/
    orderBy?: Enumerable<TopicTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TopicTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicTags
    **/
    _count?: true | TopicTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicTagMaxAggregateInputType
  }

  export type GetTopicTagAggregateType<T extends TopicTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicTag[P]>
      : GetScalarType<T[P], AggregateTopicTag[P]>
  }




  export type TopicTagGroupByArgs = {
    where?: TopicTagWhereInput
    orderBy?: Enumerable<TopicTagOrderByWithAggregationInput>
    by: Array<TopicTagScalarFieldEnum>
    having?: TopicTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicTagCountAggregateInputType | true
    _avg?: TopicTagAvgAggregateInputType
    _sum?: TopicTagSumAggregateInputType
    _min?: TopicTagMinAggregateInputType
    _max?: TopicTagMaxAggregateInputType
  }


  export type TopicTagGroupByOutputType = {
    id: number
    name: string
    slug: string
    status: string
    domainId: number
    _count: TopicTagCountAggregateOutputType | null
    _avg: TopicTagAvgAggregateOutputType | null
    _sum: TopicTagSumAggregateOutputType | null
    _min: TopicTagMinAggregateOutputType | null
    _max: TopicTagMaxAggregateOutputType | null
  }

  type GetTopicTagGroupByPayload<T extends TopicTagGroupByArgs> = Promise<
    Array<
      PickArray<TopicTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicTagGroupByOutputType[P]>
            : GetScalarType<T[P], TopicTagGroupByOutputType[P]>
        }
      >
    >


  export type TopicTagSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    status?: boolean
    domainId?: boolean
    challenges?: boolean | ChallengeFindManyArgs
    _count?: boolean | TopicTagCountOutputTypeArgs
  }

  export type TopicTagInclude = {
    challenges?: boolean | ChallengeFindManyArgs
    _count?: boolean | TopicTagCountOutputTypeArgs
  }

  export type TopicTagGetPayload<
    S extends boolean | null | undefined | TopicTagArgs,
    U = keyof S
      > = S extends true
        ? TopicTag
    : S extends undefined
    ? never
    : S extends TopicTagArgs | TopicTagFindManyArgs
    ?'include' extends U
    ? TopicTag  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'challenges'
        ? Array < ChallengeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? TopicTagCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TopicTag ?TopicTag [P]
  : 
          P extends 'challenges'
        ? Array < ChallengeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? TopicTagCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : TopicTag
  : TopicTag


  type TopicTagCountArgs = Merge<
    Omit<TopicTagFindManyArgs, 'select' | 'include'> & {
      select?: TopicTagCountAggregateInputType | true
    }
  >

  export interface TopicTagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TopicTag that matches the filter.
     * @param {TopicTagFindUniqueArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TopicTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TopicTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TopicTag'> extends True ? CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>> : CheckSelect<T, Prisma__TopicTagClient<TopicTag | null >, Prisma__TopicTagClient<TopicTagGetPayload<T> | null >>

    /**
     * Find the first TopicTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagFindFirstArgs} args - Arguments to find a TopicTag
     * @example
     * // Get one TopicTag
     * const topicTag = await prisma.topicTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TopicTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TopicTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TopicTag'> extends True ? CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>> : CheckSelect<T, Prisma__TopicTagClient<TopicTag | null >, Prisma__TopicTagClient<TopicTagGetPayload<T> | null >>

    /**
     * Find zero or more TopicTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicTags
     * const topicTags = await prisma.topicTag.findMany()
     * 
     * // Get first 10 TopicTags
     * const topicTags = await prisma.topicTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicTagWithIdOnly = await prisma.topicTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TopicTagFindManyArgs>(
      args?: SelectSubset<T, TopicTagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TopicTag>>, PrismaPromise<Array<TopicTagGetPayload<T>>>>

    /**
     * Create a TopicTag.
     * @param {TopicTagCreateArgs} args - Arguments to create a TopicTag.
     * @example
     * // Create one TopicTag
     * const TopicTag = await prisma.topicTag.create({
     *   data: {
     *     // ... data to create a TopicTag
     *   }
     * })
     * 
    **/
    create<T extends TopicTagCreateArgs>(
      args: SelectSubset<T, TopicTagCreateArgs>
    ): CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>>

    /**
     * Create many TopicTags.
     *     @param {TopicTagCreateManyArgs} args - Arguments to create many TopicTags.
     *     @example
     *     // Create many TopicTags
     *     const topicTag = await prisma.topicTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TopicTagCreateManyArgs>(
      args?: SelectSubset<T, TopicTagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TopicTag.
     * @param {TopicTagDeleteArgs} args - Arguments to delete one TopicTag.
     * @example
     * // Delete one TopicTag
     * const TopicTag = await prisma.topicTag.delete({
     *   where: {
     *     // ... filter to delete one TopicTag
     *   }
     * })
     * 
    **/
    delete<T extends TopicTagDeleteArgs>(
      args: SelectSubset<T, TopicTagDeleteArgs>
    ): CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>>

    /**
     * Update one TopicTag.
     * @param {TopicTagUpdateArgs} args - Arguments to update one TopicTag.
     * @example
     * // Update one TopicTag
     * const topicTag = await prisma.topicTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TopicTagUpdateArgs>(
      args: SelectSubset<T, TopicTagUpdateArgs>
    ): CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>>

    /**
     * Delete zero or more TopicTags.
     * @param {TopicTagDeleteManyArgs} args - Arguments to filter TopicTags to delete.
     * @example
     * // Delete a few TopicTags
     * const { count } = await prisma.topicTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TopicTagDeleteManyArgs>(
      args?: SelectSubset<T, TopicTagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicTags
     * const topicTag = await prisma.topicTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TopicTagUpdateManyArgs>(
      args: SelectSubset<T, TopicTagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TopicTag.
     * @param {TopicTagUpsertArgs} args - Arguments to update or create a TopicTag.
     * @example
     * // Update or create a TopicTag
     * const topicTag = await prisma.topicTag.upsert({
     *   create: {
     *     // ... data to create a TopicTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicTag we want to update
     *   }
     * })
    **/
    upsert<T extends TopicTagUpsertArgs>(
      args: SelectSubset<T, TopicTagUpsertArgs>
    ): CheckSelect<T, Prisma__TopicTagClient<TopicTag>, Prisma__TopicTagClient<TopicTagGetPayload<T>>>

    /**
     * Count the number of TopicTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagCountArgs} args - Arguments to filter TopicTags to count.
     * @example
     * // Count the number of TopicTags
     * const count = await prisma.topicTag.count({
     *   where: {
     *     // ... the filter for the TopicTags we want to count
     *   }
     * })
    **/
    count<T extends TopicTagCountArgs>(
      args?: Subset<T, TopicTagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicTagAggregateArgs>(args: Subset<T, TopicTagAggregateArgs>): PrismaPromise<GetTopicTagAggregateType<T>>

    /**
     * Group by TopicTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicTagGroupByArgs['orderBy'] }
        : { orderBy?: TopicTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicTagGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TopicTagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    challenges<T extends ChallengeFindManyArgs = {}>(args?: Subset<T, ChallengeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Challenge>>, PrismaPromise<Array<ChallengeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TopicTag findUnique
   */
  export type TopicTagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * Throw an Error if a TopicTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TopicTag to fetch.
     * 
    **/
    where: TopicTagWhereUniqueInput
  }


  /**
   * TopicTag findFirst
   */
  export type TopicTagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * Throw an Error if a TopicTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TopicTag to fetch.
     * 
    **/
    where?: TopicTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicTags to fetch.
     * 
    **/
    orderBy?: Enumerable<TopicTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicTags.
     * 
    **/
    cursor?: TopicTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicTags.
     * 
    **/
    distinct?: Enumerable<TopicTagScalarFieldEnum>
  }


  /**
   * TopicTag findMany
   */
  export type TopicTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * Filter, which TopicTags to fetch.
     * 
    **/
    where?: TopicTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicTags to fetch.
     * 
    **/
    orderBy?: Enumerable<TopicTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicTags.
     * 
    **/
    cursor?: TopicTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicTags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TopicTagScalarFieldEnum>
  }


  /**
   * TopicTag create
   */
  export type TopicTagCreateArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * The data needed to create a TopicTag.
     * 
    **/
    data: XOR<TopicTagCreateInput, TopicTagUncheckedCreateInput>
  }


  /**
   * TopicTag createMany
   */
  export type TopicTagCreateManyArgs = {
    /**
     * The data used to create many TopicTags.
     * 
    **/
    data: Enumerable<TopicTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TopicTag update
   */
  export type TopicTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * The data needed to update a TopicTag.
     * 
    **/
    data: XOR<TopicTagUpdateInput, TopicTagUncheckedUpdateInput>
    /**
     * Choose, which TopicTag to update.
     * 
    **/
    where: TopicTagWhereUniqueInput
  }


  /**
   * TopicTag updateMany
   */
  export type TopicTagUpdateManyArgs = {
    /**
     * The data used to update TopicTags.
     * 
    **/
    data: XOR<TopicTagUpdateManyMutationInput, TopicTagUncheckedUpdateManyInput>
    /**
     * Filter which TopicTags to update
     * 
    **/
    where?: TopicTagWhereInput
  }


  /**
   * TopicTag upsert
   */
  export type TopicTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * The filter to search for the TopicTag to update in case it exists.
     * 
    **/
    where: TopicTagWhereUniqueInput
    /**
     * In case the TopicTag found by the `where` argument doesn't exist, create a new TopicTag with this data.
     * 
    **/
    create: XOR<TopicTagCreateInput, TopicTagUncheckedCreateInput>
    /**
     * In case the TopicTag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TopicTagUpdateInput, TopicTagUncheckedUpdateInput>
  }


  /**
   * TopicTag delete
   */
  export type TopicTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
    /**
     * Filter which TopicTag to delete.
     * 
    **/
    where: TopicTagWhereUniqueInput
  }


  /**
   * TopicTag deleteMany
   */
  export type TopicTagDeleteManyArgs = {
    /**
     * Filter which TopicTags to delete
     * 
    **/
    where?: TopicTagWhereInput
  }


  /**
   * TopicTag without action
   */
  export type TopicTagArgs = {
    /**
     * Select specific fields to fetch from the TopicTag
     * 
    **/
    select?: TopicTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TopicTagInclude | null
  }



  /**
   * Model Language
   */


  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
    statusId: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
    statusId: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    title: string | null
    extension: string | null
    statusId: number | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    title: string | null
    extension: string | null
    statusId: number | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    title: number
    extension: number
    statusId: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
    statusId?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
    statusId?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    title?: true
    extension?: true
    statusId?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    title?: true
    extension?: true
    statusId?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    title?: true
    extension?: true
    statusId?: true
    _all?: true
  }

  export type LanguageAggregateArgs = {
    /**
     * Filter which Language to aggregate.
     * 
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     * 
    **/
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs = {
    where?: LanguageWhereInput
    orderBy?: Enumerable<LanguageOrderByWithAggregationInput>
    by: Array<LanguageScalarFieldEnum>
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }


  export type LanguageGroupByOutputType = {
    id: number
    title: string
    extension: string
    statusId: number
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Promise<
    Array<
      PickArray<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect = {
    id?: boolean
    title?: boolean
    extension?: boolean
    statusId?: boolean
  }

  export type LanguageGetPayload<
    S extends boolean | null | undefined | LanguageArgs,
    U = keyof S
      > = S extends true
        ? Language
    : S extends undefined
    ? never
    : S extends LanguageArgs | LanguageFindManyArgs
    ?'include' extends U
    ? Language 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Language ?Language [P]
  : 
     never
  } 
    : Language
  : Language


  type LanguageCountArgs = Merge<
    Omit<LanguageFindManyArgs, 'select' | 'include'> & {
      select?: LanguageCountAggregateInputType | true
    }
  >

  export interface LanguageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LanguageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LanguageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Language'> extends True ? CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>> : CheckSelect<T, Prisma__LanguageClient<Language | null >, Prisma__LanguageClient<LanguageGetPayload<T> | null >>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LanguageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LanguageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Language'> extends True ? CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>> : CheckSelect<T, Prisma__LanguageClient<Language | null >, Prisma__LanguageClient<LanguageGetPayload<T> | null >>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LanguageFindManyArgs>(
      args?: SelectSubset<T, LanguageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Language>>, PrismaPromise<Array<LanguageGetPayload<T>>>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends LanguageCreateArgs>(
      args: SelectSubset<T, LanguageCreateArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Create many Languages.
     *     @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LanguageCreateManyArgs>(
      args?: SelectSubset<T, LanguageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends LanguageDeleteArgs>(
      args: SelectSubset<T, LanguageDeleteArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LanguageUpdateArgs>(
      args: SelectSubset<T, LanguageUpdateArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LanguageDeleteManyArgs>(
      args?: SelectSubset<T, LanguageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LanguageUpdateManyArgs>(
      args: SelectSubset<T, LanguageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends LanguageUpsertArgs>(
      args: SelectSubset<T, LanguageUpsertArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LanguageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * Throw an Error if a Language can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Language to fetch.
     * 
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * Throw an Error if a Language can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Language to fetch.
     * 
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     * 
    **/
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     * 
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     * 
    **/
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language findMany
   */
  export type LanguageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * Filter, which Languages to fetch.
     * 
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     * 
    **/
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     * 
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language create
   */
  export type LanguageCreateArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * The data needed to create a Language.
     * 
    **/
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }


  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs = {
    /**
     * The data used to create many Languages.
     * 
    **/
    data: Enumerable<LanguageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Language update
   */
  export type LanguageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * The data needed to update a Language.
     * 
    **/
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     * 
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs = {
    /**
     * The data used to update Languages.
     * 
    **/
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     * 
    **/
    where?: LanguageWhereInput
  }


  /**
   * Language upsert
   */
  export type LanguageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * The filter to search for the Language to update in case it exists.
     * 
    **/
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     * 
    **/
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }


  /**
   * Language delete
   */
  export type LanguageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
    /**
     * Filter which Language to delete.
     * 
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs = {
    /**
     * Filter which Languages to delete
     * 
    **/
    where?: LanguageWhereInput
  }


  /**
   * Language without action
   */
  export type LanguageArgs = {
    /**
     * Select specific fields to fetch from the Language
     * 
    **/
    select?: LanguageSelect | null
  }



  /**
   * Model Status
   */


  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null
    _avg: StatusAvgAggregateOutputType | null
    _sum: StatusSumAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  export type StatusAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusSumAggregateOutputType = {
    id: number | null
  }

  export type StatusMinAggregateOutputType = {
    id: number | null
    description: string | null
    type: string | null
  }

  export type StatusMaxAggregateOutputType = {
    id: number | null
    description: string | null
    type: string | null
  }

  export type StatusCountAggregateOutputType = {
    id: number
    description: number
    type: number
    _all: number
  }


  export type StatusAvgAggregateInputType = {
    id?: true
  }

  export type StatusSumAggregateInputType = {
    id?: true
  }

  export type StatusMinAggregateInputType = {
    id?: true
    description?: true
    type?: true
  }

  export type StatusMaxAggregateInputType = {
    id?: true
    description?: true
    type?: true
  }

  export type StatusCountAggregateInputType = {
    id?: true
    description?: true
    type?: true
    _all?: true
  }

  export type StatusAggregateArgs = {
    /**
     * Filter which Status to aggregate.
     * 
    **/
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Statuses
    **/
    _count?: true | StatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusMaxAggregateInputType
  }

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>
  }




  export type StatusGroupByArgs = {
    where?: StatusWhereInput
    orderBy?: Enumerable<StatusOrderByWithAggregationInput>
    by: Array<StatusScalarFieldEnum>
    having?: StatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusCountAggregateInputType | true
    _avg?: StatusAvgAggregateInputType
    _sum?: StatusSumAggregateInputType
    _min?: StatusMinAggregateInputType
    _max?: StatusMaxAggregateInputType
  }


  export type StatusGroupByOutputType = {
    id: number
    description: string
    type: string
    _count: StatusCountAggregateOutputType | null
    _avg: StatusAvgAggregateOutputType | null
    _sum: StatusSumAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  type GetStatusGroupByPayload<T extends StatusGroupByArgs> = Promise<
    Array<
      PickArray<StatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>
        }
      >
    >


  export type StatusSelect = {
    id?: boolean
    description?: boolean
    type?: boolean
  }

  export type StatusGetPayload<
    S extends boolean | null | undefined | StatusArgs,
    U = keyof S
      > = S extends true
        ? Status
    : S extends undefined
    ? never
    : S extends StatusArgs | StatusFindManyArgs
    ?'include' extends U
    ? Status 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Status ?Status [P]
  : 
     never
  } 
    : Status
  : Status


  type StatusCountArgs = Merge<
    Omit<StatusFindManyArgs, 'select' | 'include'> & {
      select?: StatusCountAggregateInputType | true
    }
  >

  export interface StatusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Status that matches the filter.
     * @param {StatusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Status'> extends True ? CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>> : CheckSelect<T, Prisma__StatusClient<Status | null >, Prisma__StatusClient<StatusGetPayload<T> | null >>

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Status'> extends True ? CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>> : CheckSelect<T, Prisma__StatusClient<Status | null >, Prisma__StatusClient<StatusGetPayload<T> | null >>

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     * 
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusWithIdOnly = await prisma.status.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatusFindManyArgs>(
      args?: SelectSubset<T, StatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Status>>, PrismaPromise<Array<StatusGetPayload<T>>>>

    /**
     * Create a Status.
     * @param {StatusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     * 
    **/
    create<T extends StatusCreateArgs>(
      args: SelectSubset<T, StatusCreateArgs>
    ): CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>>

    /**
     * Create many Statuses.
     *     @param {StatusCreateManyArgs} args - Arguments to create many Statuses.
     *     @example
     *     // Create many Statuses
     *     const status = await prisma.status.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusCreateManyArgs>(
      args?: SelectSubset<T, StatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Status.
     * @param {StatusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     * 
    **/
    delete<T extends StatusDeleteArgs>(
      args: SelectSubset<T, StatusDeleteArgs>
    ): CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>>

    /**
     * Update one Status.
     * @param {StatusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusUpdateArgs>(
      args: SelectSubset<T, StatusUpdateArgs>
    ): CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>>

    /**
     * Delete zero or more Statuses.
     * @param {StatusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusDeleteManyArgs>(
      args?: SelectSubset<T, StatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusUpdateManyArgs>(
      args: SelectSubset<T, StatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Status.
     * @param {StatusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
    **/
    upsert<T extends StatusUpsertArgs>(
      args: SelectSubset<T, StatusUpsertArgs>
    ): CheckSelect<T, Prisma__StatusClient<Status>, Prisma__StatusClient<StatusGetPayload<T>>>

    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
    **/
    count<T extends StatusCountArgs>(
      args?: Subset<T, StatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAggregateArgs>(args: Subset<T, StatusAggregateArgs>): PrismaPromise<GetStatusAggregateType<T>>

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusGroupByArgs['orderBy'] }
        : { orderBy?: StatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Status findUnique
   */
  export type StatusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * Throw an Error if a Status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Status to fetch.
     * 
    **/
    where: StatusWhereUniqueInput
  }


  /**
   * Status findFirst
   */
  export type StatusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * Throw an Error if a Status can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Status to fetch.
     * 
    **/
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statuses.
     * 
    **/
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statuses.
     * 
    **/
    distinct?: Enumerable<StatusScalarFieldEnum>
  }


  /**
   * Status findMany
   */
  export type StatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * Filter, which Statuses to fetch.
     * 
    **/
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Statuses.
     * 
    **/
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatusScalarFieldEnum>
  }


  /**
   * Status create
   */
  export type StatusCreateArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * The data needed to create a Status.
     * 
    **/
    data: XOR<StatusCreateInput, StatusUncheckedCreateInput>
  }


  /**
   * Status createMany
   */
  export type StatusCreateManyArgs = {
    /**
     * The data used to create many Statuses.
     * 
    **/
    data: Enumerable<StatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Status update
   */
  export type StatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * The data needed to update a Status.
     * 
    **/
    data: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
    /**
     * Choose, which Status to update.
     * 
    **/
    where: StatusWhereUniqueInput
  }


  /**
   * Status updateMany
   */
  export type StatusUpdateManyArgs = {
    /**
     * The data used to update Statuses.
     * 
    **/
    data: XOR<StatusUpdateManyMutationInput, StatusUncheckedUpdateManyInput>
    /**
     * Filter which Statuses to update
     * 
    **/
    where?: StatusWhereInput
  }


  /**
   * Status upsert
   */
  export type StatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * The filter to search for the Status to update in case it exists.
     * 
    **/
    where: StatusWhereUniqueInput
    /**
     * In case the Status found by the `where` argument doesn't exist, create a new Status with this data.
     * 
    **/
    create: XOR<StatusCreateInput, StatusUncheckedCreateInput>
    /**
     * In case the Status was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
  }


  /**
   * Status delete
   */
  export type StatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
    /**
     * Filter which Status to delete.
     * 
    **/
    where: StatusWhereUniqueInput
  }


  /**
   * Status deleteMany
   */
  export type StatusDeleteManyArgs = {
    /**
     * Filter which Statuses to delete
     * 
    **/
    where?: StatusWhereInput
  }


  /**
   * Status without action
   */
  export type StatusArgs = {
    /**
     * Select specific fields to fetch from the Status
     * 
    **/
    select?: StatusSelect | null
  }



  /**
   * Model Group
   */


  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    key: string | null
    status: string | null
    description: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    key: string | null
    status: string | null
    description: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    key: number
    status: number
    description: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdByName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    status?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    status?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    status?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs = {
    /**
     * Filter which Group to aggregate.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs = {
    where?: GroupWhereInput
    orderBy?: Enumerable<GroupOrderByWithAggregationInput>
    by: Array<GroupScalarFieldEnum>
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }


  export type GroupGroupByOutputType = {
    id: number
    name: string
    key: string
    status: string
    description: string | null
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Promise<
    Array<
      PickArray<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect = {
    id?: boolean
    name?: boolean
    key?: boolean
    status?: boolean
    description?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupGetPayload<
    S extends boolean | null | undefined | GroupArgs,
    U = keyof S
      > = S extends true
        ? Group
    : S extends undefined
    ? never
    : S extends GroupArgs | GroupFindManyArgs
    ?'include' extends U
    ? Group 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Group ?Group [P]
  : 
     never
  } 
    : Group
  : Group


  type GroupCountArgs = Merge<
    Omit<GroupFindManyArgs, 'select' | 'include'> & {
      select?: GroupCountAggregateInputType | true
    }
  >

  export interface GroupDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Group'> extends True ? CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>> : CheckSelect<T, Prisma__GroupClient<Group | null >, Prisma__GroupClient<GroupGetPayload<T> | null >>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Group'> extends True ? CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>> : CheckSelect<T, Prisma__GroupClient<Group | null >, Prisma__GroupClient<GroupGetPayload<T> | null >>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFindManyArgs>(
      args?: SelectSubset<T, GroupFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Group>>, PrismaPromise<Array<GroupGetPayload<T>>>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends GroupCreateArgs>(
      args: SelectSubset<T, GroupCreateArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Create many Groups.
     *     @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupCreateManyArgs>(
      args?: SelectSubset<T, GroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends GroupDeleteArgs>(
      args: SelectSubset<T, GroupDeleteArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUpdateArgs>(
      args: SelectSubset<T, GroupUpdateArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupDeleteManyArgs>(
      args?: SelectSubset<T, GroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUpdateManyArgs>(
      args: SelectSubset<T, GroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUpsertArgs>(
      args: SelectSubset<T, GroupUpsertArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Throw an Error if a Group can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Group to fetch.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Throw an Error if a Group can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Group to fetch.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     * 
    **/
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group findMany
   */
  export type GroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Filter, which Groups to fetch.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group create
   */
  export type GroupCreateArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * The data needed to create a Group.
     * 
    **/
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }


  /**
   * Group createMany
   */
  export type GroupCreateManyArgs = {
    /**
     * The data used to create many Groups.
     * 
    **/
    data: Enumerable<GroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Group update
   */
  export type GroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * The data needed to update a Group.
     * 
    **/
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs = {
    /**
     * The data used to update Groups.
     * 
    **/
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     * 
    **/
    where?: GroupWhereInput
  }


  /**
   * Group upsert
   */
  export type GroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * The filter to search for the Group to update in case it exists.
     * 
    **/
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     * 
    **/
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }


  /**
   * Group delete
   */
  export type GroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Filter which Group to delete.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs = {
    /**
     * Filter which Groups to delete
     * 
    **/
    where?: GroupWhereInput
  }


  /**
   * Group without action
   */
  export type GroupArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
    description: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
    description: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdByName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    key: string
    name: string
    description: string | null
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Promise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Role ?Role [P]
  : 
     never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
  }



  /**
   * Model Policy
   */


  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type PolicySumAggregateOutputType = {
    id: number | null
    domainId: number | null
    createdById: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: number | null
    ptype: string | null
    subject: string | null
    object: string | null
    action: string | null
    effect: string | null
    effectWith: string | null
    condition: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: number | null
    ptype: string | null
    subject: string | null
    object: string | null
    action: string | null
    effect: string | null
    effectWith: string | null
    condition: string | null
    domainId: number | null
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    ptype: number
    subject: number
    object: number
    action: number
    effect: number
    effectWith: number
    condition: number
    domainId: number
    createdById: number
    createdByUsername: number
    createdByName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type PolicySumAggregateInputType = {
    id?: true
    domainId?: true
    createdById?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    ptype?: true
    subject?: true
    object?: true
    action?: true
    effect?: true
    effectWith?: true
    condition?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    ptype?: true
    subject?: true
    object?: true
    action?: true
    effect?: true
    effectWith?: true
    condition?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    ptype?: true
    subject?: true
    object?: true
    action?: true
    effect?: true
    effectWith?: true
    condition?: true
    domainId?: true
    createdById?: true
    createdByUsername?: true
    createdByName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PolicyAggregateArgs = {
    /**
     * Filter which Policy to aggregate.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs = {
    where?: PolicyWhereInput
    orderBy?: Enumerable<PolicyOrderByWithAggregationInput>
    by: Array<PolicyScalarFieldEnum>
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }


  export type PolicyGroupByOutputType = {
    id: number
    ptype: string
    subject: string
    object: string
    action: string
    effect: string
    effectWith: string
    condition: string | null
    domainId: number
    createdById: number | null
    createdByUsername: string | null
    createdByName: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Promise<
    Array<
      PickArray<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect = {
    id?: boolean
    ptype?: boolean
    subject?: boolean
    object?: boolean
    action?: boolean
    effect?: boolean
    effectWith?: boolean
    condition?: boolean
    domainId?: boolean
    createdById?: boolean
    createdByUsername?: boolean
    createdByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PolicyGetPayload<
    S extends boolean | null | undefined | PolicyArgs,
    U = keyof S
      > = S extends true
        ? Policy
    : S extends undefined
    ? never
    : S extends PolicyArgs | PolicyFindManyArgs
    ?'include' extends U
    ? Policy 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Policy ?Policy [P]
  : 
     never
  } 
    : Policy
  : Policy


  type PolicyCountArgs = Merge<
    Omit<PolicyFindManyArgs, 'select' | 'include'> & {
      select?: PolicyCountAggregateInputType | true
    }
  >

  export interface PolicyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PolicyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PolicyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Policy'> extends True ? CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>> : CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PolicyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PolicyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Policy'> extends True ? CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>> : CheckSelect<T, Prisma__PolicyClient<Policy | null >, Prisma__PolicyClient<PolicyGetPayload<T> | null >>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PolicyFindManyArgs>(
      args?: SelectSubset<T, PolicyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Policy>>, PrismaPromise<Array<PolicyGetPayload<T>>>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
    **/
    create<T extends PolicyCreateArgs>(
      args: SelectSubset<T, PolicyCreateArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Create many Policies.
     *     @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     *     @example
     *     // Create many Policies
     *     const policy = await prisma.policy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PolicyCreateManyArgs>(
      args?: SelectSubset<T, PolicyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
    **/
    delete<T extends PolicyDeleteArgs>(
      args: SelectSubset<T, PolicyDeleteArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PolicyUpdateArgs>(
      args: SelectSubset<T, PolicyUpdateArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PolicyDeleteManyArgs>(
      args?: SelectSubset<T, PolicyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PolicyUpdateManyArgs>(
      args: SelectSubset<T, PolicyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
    **/
    upsert<T extends PolicyUpsertArgs>(
      args: SelectSubset<T, PolicyUpsertArgs>
    ): CheckSelect<T, Prisma__PolicyClient<Policy>, Prisma__PolicyClient<PolicyGetPayload<T>>>

    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PolicyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Throw an Error if a Policy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Policy to fetch.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Throw an Error if a Policy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Policy to fetch.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     * 
    **/
    distinct?: Enumerable<PolicyScalarFieldEnum>
  }


  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Filter, which Policies to fetch.
     * 
    **/
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     * 
    **/
    orderBy?: Enumerable<PolicyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     * 
    **/
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PolicyScalarFieldEnum>
  }


  /**
   * Policy create
   */
  export type PolicyCreateArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * The data needed to create a Policy.
     * 
    **/
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }


  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs = {
    /**
     * The data used to create many Policies.
     * 
    **/
    data: Enumerable<PolicyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Policy update
   */
  export type PolicyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * The data needed to update a Policy.
     * 
    **/
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs = {
    /**
     * The data used to update Policies.
     * 
    **/
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     * 
    **/
    where?: PolicyWhereInput
  }


  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * The filter to search for the Policy to update in case it exists.
     * 
    **/
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     * 
    **/
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }


  /**
   * Policy delete
   */
  export type PolicyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
    /**
     * Filter which Policy to delete.
     * 
    **/
    where: PolicyWhereUniqueInput
  }


  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs = {
    /**
     * Filter which Policies to delete
     * 
    **/
    where?: PolicyWhereInput
  }


  /**
   * Policy without action
   */
  export type PolicyArgs = {
    /**
     * Select specific fields to fetch from the Policy
     * 
    **/
    select?: PolicySelect | null
  }



  /**
   * Model RoleGroup
   */


  export type AggregateRoleGroup = {
    _count: RoleGroupCountAggregateOutputType | null
    _avg: RoleGroupAvgAggregateOutputType | null
    _sum: RoleGroupSumAggregateOutputType | null
    _min: RoleGroupMinAggregateOutputType | null
    _max: RoleGroupMaxAggregateOutputType | null
  }

  export type RoleGroupAvgAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type RoleGroupSumAggregateOutputType = {
    id: number | null
    domainId: number | null
  }

  export type RoleGroupMinAggregateOutputType = {
    id: number | null
    ptype: string | null
    role: string | null
    rule: string | null
    domainId: number | null
  }

  export type RoleGroupMaxAggregateOutputType = {
    id: number | null
    ptype: string | null
    role: string | null
    rule: string | null
    domainId: number | null
  }

  export type RoleGroupCountAggregateOutputType = {
    id: number
    ptype: number
    role: number
    rule: number
    domainId: number
    _all: number
  }


  export type RoleGroupAvgAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type RoleGroupSumAggregateInputType = {
    id?: true
    domainId?: true
  }

  export type RoleGroupMinAggregateInputType = {
    id?: true
    ptype?: true
    role?: true
    rule?: true
    domainId?: true
  }

  export type RoleGroupMaxAggregateInputType = {
    id?: true
    ptype?: true
    role?: true
    rule?: true
    domainId?: true
  }

  export type RoleGroupCountAggregateInputType = {
    id?: true
    ptype?: true
    role?: true
    rule?: true
    domainId?: true
    _all?: true
  }

  export type RoleGroupAggregateArgs = {
    /**
     * Filter which RoleGroup to aggregate.
     * 
    **/
    where?: RoleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleGroups
    **/
    _count?: true | RoleGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleGroupMaxAggregateInputType
  }

  export type GetRoleGroupAggregateType<T extends RoleGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleGroup[P]>
      : GetScalarType<T[P], AggregateRoleGroup[P]>
  }




  export type RoleGroupGroupByArgs = {
    where?: RoleGroupWhereInput
    orderBy?: Enumerable<RoleGroupOrderByWithAggregationInput>
    by: Array<RoleGroupScalarFieldEnum>
    having?: RoleGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleGroupCountAggregateInputType | true
    _avg?: RoleGroupAvgAggregateInputType
    _sum?: RoleGroupSumAggregateInputType
    _min?: RoleGroupMinAggregateInputType
    _max?: RoleGroupMaxAggregateInputType
  }


  export type RoleGroupGroupByOutputType = {
    id: number
    ptype: string
    role: string | null
    rule: string | null
    domainId: number
    _count: RoleGroupCountAggregateOutputType | null
    _avg: RoleGroupAvgAggregateOutputType | null
    _sum: RoleGroupSumAggregateOutputType | null
    _min: RoleGroupMinAggregateOutputType | null
    _max: RoleGroupMaxAggregateOutputType | null
  }

  type GetRoleGroupGroupByPayload<T extends RoleGroupGroupByArgs> = Promise<
    Array<
      PickArray<RoleGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupGroupByOutputType[P]>
        }
      >
    >


  export type RoleGroupSelect = {
    id?: boolean
    ptype?: boolean
    role?: boolean
    rule?: boolean
    domainId?: boolean
  }

  export type RoleGroupGetPayload<
    S extends boolean | null | undefined | RoleGroupArgs,
    U = keyof S
      > = S extends true
        ? RoleGroup
    : S extends undefined
    ? never
    : S extends RoleGroupArgs | RoleGroupFindManyArgs
    ?'include' extends U
    ? RoleGroup 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RoleGroup ?RoleGroup [P]
  : 
     never
  } 
    : RoleGroup
  : RoleGroup


  type RoleGroupCountArgs = Merge<
    Omit<RoleGroupFindManyArgs, 'select' | 'include'> & {
      select?: RoleGroupCountAggregateInputType | true
    }
  >

  export interface RoleGroupDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RoleGroup that matches the filter.
     * @param {RoleGroupFindUniqueArgs} args - Arguments to find a RoleGroup
     * @example
     * // Get one RoleGroup
     * const roleGroup = await prisma.roleGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RoleGroup'> extends True ? CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>> : CheckSelect<T, Prisma__RoleGroupClient<RoleGroup | null >, Prisma__RoleGroupClient<RoleGroupGetPayload<T> | null >>

    /**
     * Find the first RoleGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupFindFirstArgs} args - Arguments to find a RoleGroup
     * @example
     * // Get one RoleGroup
     * const roleGroup = await prisma.roleGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RoleGroup'> extends True ? CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>> : CheckSelect<T, Prisma__RoleGroupClient<RoleGroup | null >, Prisma__RoleGroupClient<RoleGroupGetPayload<T> | null >>

    /**
     * Find zero or more RoleGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleGroups
     * const roleGroups = await prisma.roleGroup.findMany()
     * 
     * // Get first 10 RoleGroups
     * const roleGroups = await prisma.roleGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleGroupWithIdOnly = await prisma.roleGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleGroupFindManyArgs>(
      args?: SelectSubset<T, RoleGroupFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RoleGroup>>, PrismaPromise<Array<RoleGroupGetPayload<T>>>>

    /**
     * Create a RoleGroup.
     * @param {RoleGroupCreateArgs} args - Arguments to create a RoleGroup.
     * @example
     * // Create one RoleGroup
     * const RoleGroup = await prisma.roleGroup.create({
     *   data: {
     *     // ... data to create a RoleGroup
     *   }
     * })
     * 
    **/
    create<T extends RoleGroupCreateArgs>(
      args: SelectSubset<T, RoleGroupCreateArgs>
    ): CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>>

    /**
     * Create many RoleGroups.
     *     @param {RoleGroupCreateManyArgs} args - Arguments to create many RoleGroups.
     *     @example
     *     // Create many RoleGroups
     *     const roleGroup = await prisma.roleGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleGroupCreateManyArgs>(
      args?: SelectSubset<T, RoleGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RoleGroup.
     * @param {RoleGroupDeleteArgs} args - Arguments to delete one RoleGroup.
     * @example
     * // Delete one RoleGroup
     * const RoleGroup = await prisma.roleGroup.delete({
     *   where: {
     *     // ... filter to delete one RoleGroup
     *   }
     * })
     * 
    **/
    delete<T extends RoleGroupDeleteArgs>(
      args: SelectSubset<T, RoleGroupDeleteArgs>
    ): CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>>

    /**
     * Update one RoleGroup.
     * @param {RoleGroupUpdateArgs} args - Arguments to update one RoleGroup.
     * @example
     * // Update one RoleGroup
     * const roleGroup = await prisma.roleGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleGroupUpdateArgs>(
      args: SelectSubset<T, RoleGroupUpdateArgs>
    ): CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>>

    /**
     * Delete zero or more RoleGroups.
     * @param {RoleGroupDeleteManyArgs} args - Arguments to filter RoleGroups to delete.
     * @example
     * // Delete a few RoleGroups
     * const { count } = await prisma.roleGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleGroupDeleteManyArgs>(
      args?: SelectSubset<T, RoleGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleGroups
     * const roleGroup = await prisma.roleGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleGroupUpdateManyArgs>(
      args: SelectSubset<T, RoleGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleGroup.
     * @param {RoleGroupUpsertArgs} args - Arguments to update or create a RoleGroup.
     * @example
     * // Update or create a RoleGroup
     * const roleGroup = await prisma.roleGroup.upsert({
     *   create: {
     *     // ... data to create a RoleGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleGroup we want to update
     *   }
     * })
    **/
    upsert<T extends RoleGroupUpsertArgs>(
      args: SelectSubset<T, RoleGroupUpsertArgs>
    ): CheckSelect<T, Prisma__RoleGroupClient<RoleGroup>, Prisma__RoleGroupClient<RoleGroupGetPayload<T>>>

    /**
     * Count the number of RoleGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupCountArgs} args - Arguments to filter RoleGroups to count.
     * @example
     * // Count the number of RoleGroups
     * const count = await prisma.roleGroup.count({
     *   where: {
     *     // ... the filter for the RoleGroups we want to count
     *   }
     * })
    **/
    count<T extends RoleGroupCountArgs>(
      args?: Subset<T, RoleGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleGroupAggregateArgs>(args: Subset<T, RoleGroupAggregateArgs>): PrismaPromise<GetRoleGroupAggregateType<T>>

    /**
     * Group by RoleGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleGroupClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RoleGroup findUnique
   */
  export type RoleGroupFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * Throw an Error if a RoleGroup can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RoleGroup to fetch.
     * 
    **/
    where: RoleGroupWhereUniqueInput
  }


  /**
   * RoleGroup findFirst
   */
  export type RoleGroupFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * Throw an Error if a RoleGroup can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RoleGroup to fetch.
     * 
    **/
    where?: RoleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleGroups.
     * 
    **/
    cursor?: RoleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleGroups.
     * 
    **/
    distinct?: Enumerable<RoleGroupScalarFieldEnum>
  }


  /**
   * RoleGroup findMany
   */
  export type RoleGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * Filter, which RoleGroups to fetch.
     * 
    **/
    where?: RoleGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleGroups.
     * 
    **/
    cursor?: RoleGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleGroupScalarFieldEnum>
  }


  /**
   * RoleGroup create
   */
  export type RoleGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * The data needed to create a RoleGroup.
     * 
    **/
    data: XOR<RoleGroupCreateInput, RoleGroupUncheckedCreateInput>
  }


  /**
   * RoleGroup createMany
   */
  export type RoleGroupCreateManyArgs = {
    /**
     * The data used to create many RoleGroups.
     * 
    **/
    data: Enumerable<RoleGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RoleGroup update
   */
  export type RoleGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * The data needed to update a RoleGroup.
     * 
    **/
    data: XOR<RoleGroupUpdateInput, RoleGroupUncheckedUpdateInput>
    /**
     * Choose, which RoleGroup to update.
     * 
    **/
    where: RoleGroupWhereUniqueInput
  }


  /**
   * RoleGroup updateMany
   */
  export type RoleGroupUpdateManyArgs = {
    /**
     * The data used to update RoleGroups.
     * 
    **/
    data: XOR<RoleGroupUpdateManyMutationInput, RoleGroupUncheckedUpdateManyInput>
    /**
     * Filter which RoleGroups to update
     * 
    **/
    where?: RoleGroupWhereInput
  }


  /**
   * RoleGroup upsert
   */
  export type RoleGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * The filter to search for the RoleGroup to update in case it exists.
     * 
    **/
    where: RoleGroupWhereUniqueInput
    /**
     * In case the RoleGroup found by the `where` argument doesn't exist, create a new RoleGroup with this data.
     * 
    **/
    create: XOR<RoleGroupCreateInput, RoleGroupUncheckedCreateInput>
    /**
     * In case the RoleGroup was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleGroupUpdateInput, RoleGroupUncheckedUpdateInput>
  }


  /**
   * RoleGroup delete
   */
  export type RoleGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
    /**
     * Filter which RoleGroup to delete.
     * 
    **/
    where: RoleGroupWhereUniqueInput
  }


  /**
   * RoleGroup deleteMany
   */
  export type RoleGroupDeleteManyArgs = {
    /**
     * Filter which RoleGroups to delete
     * 
    **/
    where?: RoleGroupWhereInput
  }


  /**
   * RoleGroup without action
   */
  export type RoleGroupArgs = {
    /**
     * Select specific fields to fetch from the RoleGroup
     * 
    **/
    select?: RoleGroupSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    firstname: 'firstname',
    lastname: 'lastname',
    status: 'status',
    role: 'role',
    avatar: 'avatar',
    provider: 'provider',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdByName: 'createdByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    extendData: 'extendData'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    domainId: 'domainId',
    status: 'status'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    published: 'published',
    authorId: 'authorId',
    domainId: 'domainId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    acceptedLanguages: 'acceptedLanguages',
    languages: 'languages',
    rate: 'rate',
    audience: 'audience',
    functionName: 'functionName',
    commentCount: 'commentCount',
    contestId: 'contestId',
    status: 'status',
    categoryId: 'categoryId',
    description: 'description',
    companyTags: 'companyTags',
    contributors: 'contributors',
    examples: 'examples',
    inputs: 'inputs',
    structs: 'structs',
    types: 'types',
    output: 'output',
    highlightSolutionCount: 'highlightSolutionCount',
    hint: 'hint',
    isFavorited: 'isFavorited',
    officalSolutionCount: 'officalSolutionCount',
    testcases: 'testcases',
    difficulty: 'difficulty',
    likes: 'likes',
    dislikes: 'dislikes',
    solutions: 'solutions',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdByName: 'createdByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    languageId: 'languageId',
    challengeId: 'challengeId',
    content: 'content',
    result: 'result',
    info: 'info',
    ip: 'ip',
    shared: 'shared',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdAt: 'createdAt'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const SubmissionContestScalarFieldEnum: {
    id: 'id',
    languageId: 'languageId',
    contestId: 'contestId',
    challengeId: 'challengeId',
    content: 'content',
    result: 'result',
    ip: 'ip',
    shared: 'shared',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdAt: 'createdAt'
  };

  export type SubmissionContestScalarFieldEnum = (typeof SubmissionContestScalarFieldEnum)[keyof typeof SubmissionContestScalarFieldEnum]


  export const SubmissionStatisticScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    languageId: 'languageId',
    score: 'score',
    submitCount: 'submitCount',
    info: 'info',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    lastSubmitTime: 'lastSubmitTime'
  };

  export type SubmissionStatisticScalarFieldEnum = (typeof SubmissionStatisticScalarFieldEnum)[keyof typeof SubmissionStatisticScalarFieldEnum]


  export const SubmissionContestStatisticScalarFieldEnum: {
    id: 'id',
    contestId: 'contestId',
    info: 'info',
    domainId: 'domainId',
    createdById: 'createdById'
  };

  export type SubmissionContestStatisticScalarFieldEnum = (typeof SubmissionContestStatisticScalarFieldEnum)[keyof typeof SubmissionContestStatisticScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    status: 'status',
    domainId: 'domainId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TopicTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    status: 'status',
    domainId: 'domainId'
  };

  export type TopicTagScalarFieldEnum = (typeof TopicTagScalarFieldEnum)[keyof typeof TopicTagScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    extension: 'extension',
    statusId: 'statusId'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const StatusScalarFieldEnum: {
    id: 'id',
    description: 'description',
    type: 'type'
  };

  export type StatusScalarFieldEnum = (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    status: 'status',
    description: 'description',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdByName: 'createdByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdByName: 'createdByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    ptype: 'ptype',
    subject: 'subject',
    object: 'object',
    action: 'action',
    effect: 'effect',
    effectWith: 'effectWith',
    condition: 'condition',
    domainId: 'domainId',
    createdById: 'createdById',
    createdByUsername: 'createdByUsername',
    createdByName: 'createdByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const RoleGroupScalarFieldEnum: {
    id: 'id',
    ptype: 'ptype',
    role: 'role',
    rule: 'rule',
    domainId: 'domainId'
  };

  export type RoleGroupScalarFieldEnum = (typeof RoleGroupScalarFieldEnum)[keyof typeof RoleGroupScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    status?: StringFilter | string
    role?: StringFilter | string
    avatar?: StringNullableFilter | string | null
    provider?: StringFilter | string
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    extendData?: JsonNullableFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    status?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    provider?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extendData?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    username_domainId?: UserUsernameDomainIdCompoundUniqueInput
    email_domainId?: UserEmailDomainIdCompoundUniqueInput
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    status?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    provider?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extendData?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    firstname?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    avatar?: StringNullableWithAggregatesFilter | string | null
    provider?: StringWithAggregatesFilter | string
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdByName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    extendData?: JsonNullableWithAggregatesFilter
  }

  export type DomainWhereInput = {
    AND?: Enumerable<DomainWhereInput>
    OR?: Enumerable<DomainWhereInput>
    NOT?: Enumerable<DomainWhereInput>
    id?: IntFilter | number
    domain?: StringFilter | string
    domainId?: IntFilter | number
    status?: StringFilter | string
  }

  export type DomainOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
  }

  export type DomainWhereUniqueInput = {
    id?: number
  }

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
    _count?: DomainCountOrderByAggregateInput
    _avg?: DomainAvgOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
    _sum?: DomainSumOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DomainScalarWhereWithAggregatesInput>
    OR?: Enumerable<DomainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DomainScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    domain?: StringWithAggregatesFilter | string
    domainId?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    published?: BoolNullableFilter | boolean | null
    authorId?: IntNullableFilter | number | null
    domainId?: IntFilter | number
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    published?: BoolNullableWithAggregatesFilter | boolean | null
    authorId?: IntNullableWithAggregatesFilter | number | null
    domainId?: IntWithAggregatesFilter | number
  }

  export type ChallengeWhereInput = {
    AND?: Enumerable<ChallengeWhereInput>
    OR?: Enumerable<ChallengeWhereInput>
    NOT?: Enumerable<ChallengeWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    slug?: StringFilter | string
    acceptedLanguages?: IntNullableListFilter
    languages?: JsonNullableFilter
    rate?: FloatNullableFilter | number | null
    audience?: StringFilter | string
    functionName?: StringNullableFilter | string | null
    commentCount?: IntNullableFilter | number | null
    contestId?: IntNullableFilter | number | null
    status?: StringFilter | string
    categoryId?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    companyTags?: IntNullableListFilter
    topicTags?: TopicTagListRelationFilter
    contributors?: JsonNullableFilter
    examples?: JsonNullableFilter
    inputs?: JsonNullableFilter
    structs?: JsonNullableFilter
    types?: JsonNullableFilter
    output?: StringFilter | string
    highlightSolutionCount?: IntNullableFilter | number | null
    hint?: JsonNullableFilter
    isFavorited?: BoolFilter | boolean
    officalSolutionCount?: IntNullableFilter | number | null
    testcases?: JsonNullableFilter
    difficulty?: StringFilter | string
    likes?: IntFilter | number
    dislikes?: IntFilter | number
    solutions?: JsonNullableFilter
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    acceptedLanguages?: SortOrder
    languages?: SortOrder
    rate?: SortOrder
    audience?: SortOrder
    functionName?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    companyTags?: SortOrder
    topicTags?: TopicTagOrderByRelationAggregateInput
    contributors?: SortOrder
    examples?: SortOrder
    inputs?: SortOrder
    structs?: SortOrder
    types?: SortOrder
    output?: SortOrder
    highlightSolutionCount?: SortOrder
    hint?: SortOrder
    isFavorited?: SortOrder
    officalSolutionCount?: SortOrder
    testcases?: SortOrder
    difficulty?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    solutions?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeWhereUniqueInput = {
    id?: number
    slug_domainId?: ChallengeSlugDomainIdCompoundUniqueInput
  }

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    acceptedLanguages?: SortOrder
    languages?: SortOrder
    rate?: SortOrder
    audience?: SortOrder
    functionName?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    companyTags?: SortOrder
    contributors?: SortOrder
    examples?: SortOrder
    inputs?: SortOrder
    structs?: SortOrder
    types?: SortOrder
    output?: SortOrder
    highlightSolutionCount?: SortOrder
    hint?: SortOrder
    isFavorited?: SortOrder
    officalSolutionCount?: SortOrder
    testcases?: SortOrder
    difficulty?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    solutions?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChallengeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChallengeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChallengeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    acceptedLanguages?: IntNullableListFilter
    languages?: JsonNullableWithAggregatesFilter
    rate?: FloatNullableWithAggregatesFilter | number | null
    audience?: StringWithAggregatesFilter | string
    functionName?: StringNullableWithAggregatesFilter | string | null
    commentCount?: IntNullableWithAggregatesFilter | number | null
    contestId?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
    categoryId?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    companyTags?: IntNullableListFilter
    contributors?: JsonNullableWithAggregatesFilter
    examples?: JsonNullableWithAggregatesFilter
    inputs?: JsonNullableWithAggregatesFilter
    structs?: JsonNullableWithAggregatesFilter
    types?: JsonNullableWithAggregatesFilter
    output?: StringWithAggregatesFilter | string
    highlightSolutionCount?: IntNullableWithAggregatesFilter | number | null
    hint?: JsonNullableWithAggregatesFilter
    isFavorited?: BoolWithAggregatesFilter | boolean
    officalSolutionCount?: IntNullableWithAggregatesFilter | number | null
    testcases?: JsonNullableWithAggregatesFilter
    difficulty?: StringWithAggregatesFilter | string
    likes?: IntWithAggregatesFilter | number
    dislikes?: IntWithAggregatesFilter | number
    solutions?: JsonNullableWithAggregatesFilter
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdByName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SubmissionWhereInput = {
    AND?: Enumerable<SubmissionWhereInput>
    OR?: Enumerable<SubmissionWhereInput>
    NOT?: Enumerable<SubmissionWhereInput>
    id?: IntFilter | number
    languageId?: StringNullableFilter | string | null
    challengeId?: IntNullableFilter | number | null
    content?: StringFilter | string
    result?: JsonNullableFilter
    info?: JsonNullableFilter
    ip?: StringNullableFilter | string | null
    shared?: BoolFilter | boolean
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    languageId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    info?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionWhereUniqueInput = {
    id?: number
  }

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    languageId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    info?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    languageId?: StringNullableWithAggregatesFilter | string | null
    challengeId?: IntNullableWithAggregatesFilter | number | null
    content?: StringWithAggregatesFilter | string
    result?: JsonNullableWithAggregatesFilter
    info?: JsonNullableWithAggregatesFilter
    ip?: StringNullableWithAggregatesFilter | string | null
    shared?: BoolWithAggregatesFilter | boolean
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubmissionContestWhereInput = {
    AND?: Enumerable<SubmissionContestWhereInput>
    OR?: Enumerable<SubmissionContestWhereInput>
    NOT?: Enumerable<SubmissionContestWhereInput>
    id?: IntFilter | number
    languageId?: StringNullableFilter | string | null
    contestId?: IntNullableFilter | number | null
    challengeId?: IntNullableFilter | number | null
    content?: StringFilter | string
    result?: JsonNullableFilter
    ip?: StringNullableFilter | string | null
    shared?: BoolFilter | boolean
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type SubmissionContestOrderByWithRelationInput = {
    id?: SortOrder
    languageId?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionContestWhereUniqueInput = {
    id?: number
  }

  export type SubmissionContestOrderByWithAggregationInput = {
    id?: SortOrder
    languageId?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
    _count?: SubmissionContestCountOrderByAggregateInput
    _avg?: SubmissionContestAvgOrderByAggregateInput
    _max?: SubmissionContestMaxOrderByAggregateInput
    _min?: SubmissionContestMinOrderByAggregateInput
    _sum?: SubmissionContestSumOrderByAggregateInput
  }

  export type SubmissionContestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubmissionContestScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubmissionContestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubmissionContestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    languageId?: StringNullableWithAggregatesFilter | string | null
    contestId?: IntNullableWithAggregatesFilter | number | null
    challengeId?: IntNullableWithAggregatesFilter | number | null
    content?: StringWithAggregatesFilter | string
    result?: JsonNullableWithAggregatesFilter
    ip?: StringNullableWithAggregatesFilter | string | null
    shared?: BoolWithAggregatesFilter | boolean
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubmissionStatisticWhereInput = {
    AND?: Enumerable<SubmissionStatisticWhereInput>
    OR?: Enumerable<SubmissionStatisticWhereInput>
    NOT?: Enumerable<SubmissionStatisticWhereInput>
    id?: IntFilter | number
    challengeId?: IntNullableFilter | number | null
    languageId?: StringNullableFilter | string | null
    score?: IntFilter | number
    submitCount?: IntFilter | number
    info?: JsonNullableFilter
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    lastSubmitTime?: DateTimeFilter | Date | string
  }

  export type SubmissionStatisticOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    languageId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    lastSubmitTime?: SortOrder
  }

  export type SubmissionStatisticWhereUniqueInput = {
    id?: number
    createdById_challengeId?: SubmissionStatisticCreatedByIdChallengeIdCompoundUniqueInput
  }

  export type SubmissionStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    languageId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    lastSubmitTime?: SortOrder
    _count?: SubmissionStatisticCountOrderByAggregateInput
    _avg?: SubmissionStatisticAvgOrderByAggregateInput
    _max?: SubmissionStatisticMaxOrderByAggregateInput
    _min?: SubmissionStatisticMinOrderByAggregateInput
    _sum?: SubmissionStatisticSumOrderByAggregateInput
  }

  export type SubmissionStatisticScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubmissionStatisticScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubmissionStatisticScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubmissionStatisticScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    challengeId?: IntNullableWithAggregatesFilter | number | null
    languageId?: StringNullableWithAggregatesFilter | string | null
    score?: IntWithAggregatesFilter | number
    submitCount?: IntWithAggregatesFilter | number
    info?: JsonNullableWithAggregatesFilter
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    lastSubmitTime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubmissionContestStatisticWhereInput = {
    AND?: Enumerable<SubmissionContestStatisticWhereInput>
    OR?: Enumerable<SubmissionContestStatisticWhereInput>
    NOT?: Enumerable<SubmissionContestStatisticWhereInput>
    id?: IntFilter | number
    contestId?: IntNullableFilter | number | null
    info?: JsonNullableFilter
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
  }

  export type SubmissionContestStatisticOrderByWithRelationInput = {
    id?: SortOrder
    contestId?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticWhereUniqueInput = {
    id?: number
  }

  export type SubmissionContestStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    contestId?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    _count?: SubmissionContestStatisticCountOrderByAggregateInput
    _avg?: SubmissionContestStatisticAvgOrderByAggregateInput
    _max?: SubmissionContestStatisticMaxOrderByAggregateInput
    _min?: SubmissionContestStatisticMinOrderByAggregateInput
    _sum?: SubmissionContestStatisticSumOrderByAggregateInput
  }

  export type SubmissionContestStatisticScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubmissionContestStatisticScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubmissionContestStatisticScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubmissionContestStatisticScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    contestId?: IntNullableWithAggregatesFilter | number | null
    info?: JsonNullableWithAggregatesFilter
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    status?: StringFilter | string
    domainId?: IntFilter | number
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: number
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    domainId?: IntWithAggregatesFilter | number
  }

  export type TopicTagWhereInput = {
    AND?: Enumerable<TopicTagWhereInput>
    OR?: Enumerable<TopicTagWhereInput>
    NOT?: Enumerable<TopicTagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    status?: StringFilter | string
    domainId?: IntFilter | number
    challenges?: ChallengeListRelationFilter
  }

  export type TopicTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
    challenges?: ChallengeOrderByRelationAggregateInput
  }

  export type TopicTagWhereUniqueInput = {
    id?: number
  }

  export type TopicTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
    _count?: TopicTagCountOrderByAggregateInput
    _avg?: TopicTagAvgOrderByAggregateInput
    _max?: TopicTagMaxOrderByAggregateInput
    _min?: TopicTagMinOrderByAggregateInput
    _sum?: TopicTagSumOrderByAggregateInput
  }

  export type TopicTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TopicTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TopicTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TopicTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    domainId?: IntWithAggregatesFilter | number
  }

  export type LanguageWhereInput = {
    AND?: Enumerable<LanguageWhereInput>
    OR?: Enumerable<LanguageWhereInput>
    NOT?: Enumerable<LanguageWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    extension?: StringFilter | string
    statusId?: IntFilter | number
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    extension?: SortOrder
    statusId?: SortOrder
  }

  export type LanguageWhereUniqueInput = {
    id?: number
  }

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    extension?: SortOrder
    statusId?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    OR?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    extension?: StringWithAggregatesFilter | string
    statusId?: IntWithAggregatesFilter | number
  }

  export type StatusWhereInput = {
    AND?: Enumerable<StatusWhereInput>
    OR?: Enumerable<StatusWhereInput>
    NOT?: Enumerable<StatusWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    type?: StringFilter | string
  }

  export type StatusOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type StatusWhereUniqueInput = {
    id?: number
  }

  export type StatusOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    type?: SortOrder
    _count?: StatusCountOrderByAggregateInput
    _avg?: StatusAvgOrderByAggregateInput
    _max?: StatusMaxOrderByAggregateInput
    _min?: StatusMinOrderByAggregateInput
    _sum?: StatusSumOrderByAggregateInput
  }

  export type StatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatusScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
  }

  export type GroupWhereInput = {
    AND?: Enumerable<GroupWhereInput>
    OR?: Enumerable<GroupWhereInput>
    NOT?: Enumerable<GroupWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    key?: StringFilter | string
    status?: StringFilter | string
    description?: StringNullableFilter | string | null
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    status?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupWhereUniqueInput = {
    id?: number
  }

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    status?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdByName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    key?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleWhereUniqueInput = {
    id?: number
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    key?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdByName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PolicyWhereInput = {
    AND?: Enumerable<PolicyWhereInput>
    OR?: Enumerable<PolicyWhereInput>
    NOT?: Enumerable<PolicyWhereInput>
    id?: IntFilter | number
    ptype?: StringFilter | string
    subject?: StringFilter | string
    object?: StringFilter | string
    action?: StringFilter | string
    effect?: StringFilter | string
    effectWith?: StringFilter | string
    condition?: StringNullableFilter | string | null
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    ptype?: SortOrder
    subject?: SortOrder
    object?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    effectWith?: SortOrder
    condition?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyWhereUniqueInput = {
    id?: number
  }

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    ptype?: SortOrder
    subject?: SortOrder
    object?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    effectWith?: SortOrder
    condition?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    OR?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PolicyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ptype?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    object?: StringWithAggregatesFilter | string
    action?: StringWithAggregatesFilter | string
    effect?: StringWithAggregatesFilter | string
    effectWith?: StringWithAggregatesFilter | string
    condition?: StringNullableWithAggregatesFilter | string | null
    domainId?: IntWithAggregatesFilter | number
    createdById?: IntNullableWithAggregatesFilter | number | null
    createdByUsername?: StringNullableWithAggregatesFilter | string | null
    createdByName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RoleGroupWhereInput = {
    AND?: Enumerable<RoleGroupWhereInput>
    OR?: Enumerable<RoleGroupWhereInput>
    NOT?: Enumerable<RoleGroupWhereInput>
    id?: IntFilter | number
    ptype?: StringFilter | string
    role?: StringNullableFilter | string | null
    rule?: StringNullableFilter | string | null
    domainId?: IntFilter | number
  }

  export type RoleGroupOrderByWithRelationInput = {
    id?: SortOrder
    ptype?: SortOrder
    role?: SortOrder
    rule?: SortOrder
    domainId?: SortOrder
  }

  export type RoleGroupWhereUniqueInput = {
    id?: number
  }

  export type RoleGroupOrderByWithAggregationInput = {
    id?: SortOrder
    ptype?: SortOrder
    role?: SortOrder
    rule?: SortOrder
    domainId?: SortOrder
    _count?: RoleGroupCountOrderByAggregateInput
    _avg?: RoleGroupAvgOrderByAggregateInput
    _max?: RoleGroupMaxOrderByAggregateInput
    _min?: RoleGroupMinOrderByAggregateInput
    _sum?: RoleGroupSumOrderByAggregateInput
  }

  export type RoleGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleGroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ptype?: StringWithAggregatesFilter | string
    role?: StringNullableWithAggregatesFilter | string | null
    rule?: StringNullableWithAggregatesFilter | string | null
    domainId?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    email?: string
    username?: string
    password?: string
    firstname?: string
    lastname?: string
    status?: string
    role?: string
    avatar?: string | null
    provider?: string
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email?: string
    username?: string
    password?: string
    firstname?: string
    lastname?: string
    status?: string
    role?: string
    avatar?: string | null
    provider?: string
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateManyInput = {
    id?: number
    email?: string
    username?: string
    password?: string
    firstname?: string
    lastname?: string
    status?: string
    role?: string
    avatar?: string | null
    provider?: string
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DomainCreateInput = {
    domain?: string
    domainId?: number
    status?: string
  }

  export type DomainUncheckedCreateInput = {
    id?: number
    domain?: string
    domainId?: number
    status?: string
  }

  export type DomainUpdateInput = {
    domain?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainCreateManyInput = {
    id?: number
    domain?: string
    domainId?: number
    status?: string
  }

  export type DomainUpdateManyMutationInput = {
    domain?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domain?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    title: string
    content?: string | null
    published?: boolean | null
    authorId?: number | null
    domainId?: number
  }

  export type PostUncheckedCreateInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean | null
    authorId?: number | null
    domainId?: number
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateManyInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean | null
    authorId?: number | null
    domainId?: number
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeCreateInput = {
    title: string
    slug?: string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: number | null
    audience?: string
    functionName?: string | null
    commentCount?: number | null
    contestId?: number | null
    status?: string
    categoryId?: number | null
    description?: string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output: string
    highlightSolutionCount?: number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: boolean
    officalSolutionCount?: number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string
    likes?: number
    dislikes?: number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedLanguages?: ChallengeCreateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeCreatecompanyTagsInput | Enumerable<number>
    topicTags?: TopicTagCreateNestedManyWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: number
    title: string
    slug?: string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: number | null
    audience?: string
    functionName?: string | null
    commentCount?: number | null
    contestId?: number | null
    status?: string
    categoryId?: number | null
    description?: string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output: string
    highlightSolutionCount?: number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: boolean
    officalSolutionCount?: number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string
    likes?: number
    dislikes?: number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedLanguages?: ChallengeCreateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeCreatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
    topicTags?: TopicTagUpdateManyWithoutChallengesInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeCreateManyInput = {
    id?: number
    title: string
    slug?: string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: number | null
    audience?: string
    functionName?: string | null
    commentCount?: number | null
    contestId?: number | null
    status?: string
    categoryId?: number | null
    description?: string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output: string
    highlightSolutionCount?: number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: boolean
    officalSolutionCount?: number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string
    likes?: number
    dislikes?: number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedLanguages?: ChallengeCreateManyacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeCreateManycompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }

  export type SubmissionCreateInput = {
    languageId?: string | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionUncheckedCreateInput = {
    id?: number
    languageId?: string | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionUpdateInput = {
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateManyInput = {
    id?: number
    languageId?: string | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionUpdateManyMutationInput = {
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    info?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionContestCreateInput = {
    languageId?: string | null
    contestId?: number | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionContestUncheckedCreateInput = {
    id?: number
    languageId?: string | null
    contestId?: number | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionContestUpdateInput = {
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionContestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionContestCreateManyInput = {
    id?: number
    languageId?: string | null
    contestId?: number | null
    challengeId?: number | null
    content: string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    shared?: boolean
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdAt?: Date | string
  }

  export type SubmissionContestUpdateManyMutationInput = {
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionContestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    result?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    shared?: BoolFieldUpdateOperationsInput | boolean
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionStatisticCreateInput = {
    challengeId?: number | null
    languageId?: string | null
    score?: number
    submitCount?: number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    lastSubmitTime?: Date | string
  }

  export type SubmissionStatisticUncheckedCreateInput = {
    id?: number
    challengeId?: number | null
    languageId?: string | null
    score?: number
    submitCount?: number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    lastSubmitTime?: Date | string
  }

  export type SubmissionStatisticUpdateInput = {
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    submitCount?: IntFieldUpdateOperationsInput | number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastSubmitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionStatisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    submitCount?: IntFieldUpdateOperationsInput | number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastSubmitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionStatisticCreateManyInput = {
    id?: number
    challengeId?: number | null
    languageId?: string | null
    score?: number
    submitCount?: number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    lastSubmitTime?: Date | string
  }

  export type SubmissionStatisticUpdateManyMutationInput = {
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    submitCount?: IntFieldUpdateOperationsInput | number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastSubmitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionStatisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: NullableIntFieldUpdateOperationsInput | number | null
    languageId?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    submitCount?: IntFieldUpdateOperationsInput | number
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    lastSubmitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionContestStatisticCreateInput = {
    contestId?: number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
  }

  export type SubmissionContestStatisticUncheckedCreateInput = {
    id?: number
    contestId?: number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
  }

  export type SubmissionContestStatisticUpdateInput = {
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubmissionContestStatisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubmissionContestStatisticCreateManyInput = {
    id?: number
    contestId?: number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
  }

  export type SubmissionContestStatisticUpdateManyMutationInput = {
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubmissionContestStatisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    info?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type TopicTagCreateInput = {
    name: string
    slug?: string
    status?: string
    domainId?: number
    challenges?: ChallengeCreateNestedManyWithoutTopicTagsInput
  }

  export type TopicTagUncheckedCreateInput = {
    id?: number
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type TopicTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
    challenges?: ChallengeUpdateManyWithoutTopicTagsInput
  }

  export type TopicTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type TopicTagCreateManyInput = {
    id?: number
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type TopicTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type TopicTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    title: string
    extension: string
    statusId?: number
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    title: string
    extension: string
    statusId?: number
  }

  export type LanguageUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateManyInput = {
    id?: number
    title: string
    extension: string
    statusId?: number
  }

  export type LanguageUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
  }

  export type StatusCreateInput = {
    description: string
    type?: string
  }

  export type StatusUncheckedCreateInput = {
    id?: number
    description: string
    type?: string
  }

  export type StatusUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type StatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type StatusCreateManyInput = {
    id?: number
    description: string
    type?: string
  }

  export type StatusUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type StatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    name?: string
    key?: string
    status?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name?: string
    key?: string
    status?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupCreateManyInput = {
    id?: number
    name?: string
    key?: string
    status?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    key?: string
    name?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    key?: string
    name?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RoleUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateManyInput = {
    id?: number
    key?: string
    name?: string
    description?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RoleUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyCreateInput = {
    ptype?: string
    subject?: string
    object?: string
    action?: string
    effect?: string
    effectWith?: string
    condition?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PolicyUncheckedCreateInput = {
    id?: number
    ptype?: string
    subject?: string
    object?: string
    action?: string
    effect?: string
    effectWith?: string
    condition?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PolicyUpdateInput = {
    ptype?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    effect?: StringFieldUpdateOperationsInput | string
    effectWith?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ptype?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    effect?: StringFieldUpdateOperationsInput | string
    effectWith?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyCreateManyInput = {
    id?: number
    ptype?: string
    subject?: string
    object?: string
    action?: string
    effect?: string
    effectWith?: string
    condition?: string | null
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PolicyUpdateManyMutationInput = {
    ptype?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    effect?: StringFieldUpdateOperationsInput | string
    effectWith?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ptype?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    effect?: StringFieldUpdateOperationsInput | string
    effectWith?: StringFieldUpdateOperationsInput | string
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleGroupCreateInput = {
    ptype?: string
    role?: string | null
    rule?: string | null
    domainId?: number
  }

  export type RoleGroupUncheckedCreateInput = {
    id?: number
    ptype?: string
    role?: string | null
    rule?: string | null
    domainId?: number
  }

  export type RoleGroupUpdateInput = {
    ptype?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ptype?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleGroupCreateManyInput = {
    id?: number
    ptype?: string
    role?: string | null
    rule?: string | null
    domainId?: number
  }

  export type RoleGroupUpdateManyMutationInput = {
    ptype?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ptype?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type UserUsernameDomainIdCompoundUniqueInput = {
    username: string
    domainId: number
  }

  export type UserEmailDomainIdCompoundUniqueInput = {
    email: string
    domainId: number
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    status?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    provider?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extendData?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    status?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    provider?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    status?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    provider?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
  }

  export type DomainAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    domainId?: SortOrder
    status?: SortOrder
  }

  export type DomainSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    domainId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type IntNullableListFilter = {
    equals?: Enumerable<number> | null
    has?: number | null
    hasEvery?: Enumerable<number>
    hasSome?: Enumerable<number>
    isEmpty?: boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type TopicTagListRelationFilter = {
    every?: TopicTagWhereInput
    some?: TopicTagWhereInput
    none?: TopicTagWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TopicTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeSlugDomainIdCompoundUniqueInput = {
    slug: string
    domainId: number
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    acceptedLanguages?: SortOrder
    languages?: SortOrder
    rate?: SortOrder
    audience?: SortOrder
    functionName?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    companyTags?: SortOrder
    contributors?: SortOrder
    examples?: SortOrder
    inputs?: SortOrder
    structs?: SortOrder
    types?: SortOrder
    output?: SortOrder
    highlightSolutionCount?: SortOrder
    hint?: SortOrder
    isFavorited?: SortOrder
    officalSolutionCount?: SortOrder
    testcases?: SortOrder
    difficulty?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    solutions?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
    acceptedLanguages?: SortOrder
    rate?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    categoryId?: SortOrder
    companyTags?: SortOrder
    highlightSolutionCount?: SortOrder
    officalSolutionCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    rate?: SortOrder
    audience?: SortOrder
    functionName?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    output?: SortOrder
    highlightSolutionCount?: SortOrder
    isFavorited?: SortOrder
    officalSolutionCount?: SortOrder
    difficulty?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    rate?: SortOrder
    audience?: SortOrder
    functionName?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    output?: SortOrder
    highlightSolutionCount?: SortOrder
    isFavorited?: SortOrder
    officalSolutionCount?: SortOrder
    difficulty?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    id?: SortOrder
    acceptedLanguages?: SortOrder
    rate?: SortOrder
    commentCount?: SortOrder
    contestId?: SortOrder
    categoryId?: SortOrder
    companyTags?: SortOrder
    highlightSolutionCount?: SortOrder
    officalSolutionCount?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    info?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestCountOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    result?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionContestAvgOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestMaxOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionContestMinOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    content?: SortOrder
    ip?: SortOrder
    shared?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionContestSumOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    challengeId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionStatisticCreatedByIdChallengeIdCompoundUniqueInput = {
    createdById: number
    challengeId: number
  }

  export type SubmissionStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    languageId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    lastSubmitTime?: SortOrder
  }

  export type SubmissionStatisticAvgOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    languageId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    lastSubmitTime?: SortOrder
  }

  export type SubmissionStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    languageId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    lastSubmitTime?: SortOrder
  }

  export type SubmissionStatisticSumOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    score?: SortOrder
    submitCount?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    info?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticAvgOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type SubmissionContestStatisticSumOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput
    some?: ChallengeWhereInput
    none?: ChallengeWhereInput
  }

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type TopicTagAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type TopicTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type TopicTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    domainId?: SortOrder
  }

  export type TopicTagSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    extension?: SortOrder
    statusId?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    extension?: SortOrder
    statusId?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    extension?: SortOrder
    statusId?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
    statusId?: SortOrder
  }

  export type StatusCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type StatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type StatusMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type StatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    status?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    status?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    status?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    subject?: SortOrder
    object?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    effectWith?: SortOrder
    condition?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    subject?: SortOrder
    object?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    effectWith?: SortOrder
    condition?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    subject?: SortOrder
    object?: SortOrder
    action?: SortOrder
    effect?: SortOrder
    effectWith?: SortOrder
    condition?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
    createdByUsername?: SortOrder
    createdByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
    createdById?: SortOrder
  }

  export type RoleGroupCountOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    role?: SortOrder
    rule?: SortOrder
    domainId?: SortOrder
  }

  export type RoleGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type RoleGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    role?: SortOrder
    rule?: SortOrder
    domainId?: SortOrder
  }

  export type RoleGroupMinOrderByAggregateInput = {
    id?: SortOrder
    ptype?: SortOrder
    role?: SortOrder
    rule?: SortOrder
    domainId?: SortOrder
  }

  export type RoleGroupSumOrderByAggregateInput = {
    id?: SortOrder
    domainId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ChallengeCreateacceptedLanguagesInput = {
    set: Enumerable<number>
  }

  export type ChallengeCreatecompanyTagsInput = {
    set: Enumerable<number>
  }

  export type TopicTagCreateNestedManyWithoutChallengesInput = {
    create?: XOR<Enumerable<TopicTagCreateWithoutChallengesInput>, Enumerable<TopicTagUncheckedCreateWithoutChallengesInput>>
    connectOrCreate?: Enumerable<TopicTagCreateOrConnectWithoutChallengesInput>
    connect?: Enumerable<TopicTagWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ChallengeUpdateacceptedLanguagesInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type ChallengeUpdatecompanyTagsInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type TopicTagUpdateManyWithoutChallengesInput = {
    create?: XOR<Enumerable<TopicTagCreateWithoutChallengesInput>, Enumerable<TopicTagUncheckedCreateWithoutChallengesInput>>
    connectOrCreate?: Enumerable<TopicTagCreateOrConnectWithoutChallengesInput>
    upsert?: Enumerable<TopicTagUpsertWithWhereUniqueWithoutChallengesInput>
    set?: Enumerable<TopicTagWhereUniqueInput>
    disconnect?: Enumerable<TopicTagWhereUniqueInput>
    delete?: Enumerable<TopicTagWhereUniqueInput>
    connect?: Enumerable<TopicTagWhereUniqueInput>
    update?: Enumerable<TopicTagUpdateWithWhereUniqueWithoutChallengesInput>
    updateMany?: Enumerable<TopicTagUpdateManyWithWhereWithoutChallengesInput>
    deleteMany?: Enumerable<TopicTagScalarWhereInput>
  }

  export type ChallengeCreateManyacceptedLanguagesInput = {
    set: Enumerable<number>
  }

  export type ChallengeCreateManycompanyTagsInput = {
    set: Enumerable<number>
  }

  export type ChallengeCreateNestedManyWithoutTopicTagsInput = {
    create?: XOR<Enumerable<ChallengeCreateWithoutTopicTagsInput>, Enumerable<ChallengeUncheckedCreateWithoutTopicTagsInput>>
    connectOrCreate?: Enumerable<ChallengeCreateOrConnectWithoutTopicTagsInput>
    connect?: Enumerable<ChallengeWhereUniqueInput>
  }

  export type ChallengeUpdateManyWithoutTopicTagsInput = {
    create?: XOR<Enumerable<ChallengeCreateWithoutTopicTagsInput>, Enumerable<ChallengeUncheckedCreateWithoutTopicTagsInput>>
    connectOrCreate?: Enumerable<ChallengeCreateOrConnectWithoutTopicTagsInput>
    upsert?: Enumerable<ChallengeUpsertWithWhereUniqueWithoutTopicTagsInput>
    set?: Enumerable<ChallengeWhereUniqueInput>
    disconnect?: Enumerable<ChallengeWhereUniqueInput>
    delete?: Enumerable<ChallengeWhereUniqueInput>
    connect?: Enumerable<ChallengeWhereUniqueInput>
    update?: Enumerable<ChallengeUpdateWithWhereUniqueWithoutTopicTagsInput>
    updateMany?: Enumerable<ChallengeUpdateManyWithWhereWithoutTopicTagsInput>
    deleteMany?: Enumerable<ChallengeScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type TopicTagCreateWithoutChallengesInput = {
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type TopicTagUncheckedCreateWithoutChallengesInput = {
    id?: number
    name: string
    slug?: string
    status?: string
    domainId?: number
  }

  export type TopicTagCreateOrConnectWithoutChallengesInput = {
    where: TopicTagWhereUniqueInput
    create: XOR<TopicTagCreateWithoutChallengesInput, TopicTagUncheckedCreateWithoutChallengesInput>
  }

  export type TopicTagUpsertWithWhereUniqueWithoutChallengesInput = {
    where: TopicTagWhereUniqueInput
    update: XOR<TopicTagUpdateWithoutChallengesInput, TopicTagUncheckedUpdateWithoutChallengesInput>
    create: XOR<TopicTagCreateWithoutChallengesInput, TopicTagUncheckedCreateWithoutChallengesInput>
  }

  export type TopicTagUpdateWithWhereUniqueWithoutChallengesInput = {
    where: TopicTagWhereUniqueInput
    data: XOR<TopicTagUpdateWithoutChallengesInput, TopicTagUncheckedUpdateWithoutChallengesInput>
  }

  export type TopicTagUpdateManyWithWhereWithoutChallengesInput = {
    where: TopicTagScalarWhereInput
    data: XOR<TopicTagUpdateManyMutationInput, TopicTagUncheckedUpdateManyWithoutTopicTagsInput>
  }

  export type TopicTagScalarWhereInput = {
    AND?: Enumerable<TopicTagScalarWhereInput>
    OR?: Enumerable<TopicTagScalarWhereInput>
    NOT?: Enumerable<TopicTagScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    status?: StringFilter | string
    domainId?: IntFilter | number
  }

  export type ChallengeCreateWithoutTopicTagsInput = {
    title: string
    slug?: string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: number | null
    audience?: string
    functionName?: string | null
    commentCount?: number | null
    contestId?: number | null
    status?: string
    categoryId?: number | null
    description?: string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output: string
    highlightSolutionCount?: number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: boolean
    officalSolutionCount?: number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string
    likes?: number
    dislikes?: number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedLanguages?: ChallengeCreateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeCreatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUncheckedCreateWithoutTopicTagsInput = {
    id?: number
    title: string
    slug?: string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: number | null
    audience?: string
    functionName?: string | null
    commentCount?: number | null
    contestId?: number | null
    status?: string
    categoryId?: number | null
    description?: string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output: string
    highlightSolutionCount?: number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: boolean
    officalSolutionCount?: number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string
    likes?: number
    dislikes?: number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: number
    createdById?: number | null
    createdByUsername?: string | null
    createdByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedLanguages?: ChallengeCreateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeCreatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeCreateOrConnectWithoutTopicTagsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTopicTagsInput, ChallengeUncheckedCreateWithoutTopicTagsInput>
  }

  export type ChallengeUpsertWithWhereUniqueWithoutTopicTagsInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutTopicTagsInput, ChallengeUncheckedUpdateWithoutTopicTagsInput>
    create: XOR<ChallengeCreateWithoutTopicTagsInput, ChallengeUncheckedCreateWithoutTopicTagsInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutTopicTagsInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutTopicTagsInput, ChallengeUncheckedUpdateWithoutTopicTagsInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutTopicTagsInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutChallengesInput>
  }

  export type ChallengeScalarWhereInput = {
    AND?: Enumerable<ChallengeScalarWhereInput>
    OR?: Enumerable<ChallengeScalarWhereInput>
    NOT?: Enumerable<ChallengeScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    slug?: StringFilter | string
    acceptedLanguages?: IntNullableListFilter
    languages?: JsonNullableFilter
    rate?: FloatNullableFilter | number | null
    audience?: StringFilter | string
    functionName?: StringNullableFilter | string | null
    commentCount?: IntNullableFilter | number | null
    contestId?: IntNullableFilter | number | null
    status?: StringFilter | string
    categoryId?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    companyTags?: IntNullableListFilter
    contributors?: JsonNullableFilter
    examples?: JsonNullableFilter
    inputs?: JsonNullableFilter
    structs?: JsonNullableFilter
    types?: JsonNullableFilter
    output?: StringFilter | string
    highlightSolutionCount?: IntNullableFilter | number | null
    hint?: JsonNullableFilter
    isFavorited?: BoolFilter | boolean
    officalSolutionCount?: IntNullableFilter | number | null
    testcases?: JsonNullableFilter
    difficulty?: StringFilter | string
    likes?: IntFilter | number
    dislikes?: IntFilter | number
    solutions?: JsonNullableFilter
    domainId?: IntFilter | number
    createdById?: IntNullableFilter | number | null
    createdByUsername?: StringNullableFilter | string | null
    createdByName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TopicTagUpdateWithoutChallengesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type TopicTagUncheckedUpdateWithoutChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type TopicTagUncheckedUpdateManyWithoutTopicTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    domainId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeUpdateWithoutTopicTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUncheckedUpdateWithoutTopicTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }

  export type ChallengeUncheckedUpdateManyWithoutChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    languages?: NullableJsonNullValueInput | InputJsonValue
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    audience?: StringFieldUpdateOperationsInput | string
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: NullableIntFieldUpdateOperationsInput | number | null
    contestId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    inputs?: NullableJsonNullValueInput | InputJsonValue
    structs?: NullableJsonNullValueInput | InputJsonValue
    types?: NullableJsonNullValueInput | InputJsonValue
    output?: StringFieldUpdateOperationsInput | string
    highlightSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    hint?: NullableJsonNullValueInput | InputJsonValue
    isFavorited?: BoolFieldUpdateOperationsInput | boolean
    officalSolutionCount?: NullableIntFieldUpdateOperationsInput | number | null
    testcases?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    solutions?: NullableJsonNullValueInput | InputJsonValue
    domainId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUsername?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedLanguages?: ChallengeUpdateacceptedLanguagesInput | Enumerable<number>
    companyTags?: ChallengeUpdatecompanyTagsInput | Enumerable<number>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}