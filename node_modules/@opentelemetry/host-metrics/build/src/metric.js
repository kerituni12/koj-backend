"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HostMetrics = void 0;
const BaseMetrics_1 = require("./BaseMetrics");
const enums = require("./enum");
const common_1 = require("./stats/common");
const si_1 = require("./stats/si");
const util_1 = require("./util");
/**
 * Metrics Collector - collects metrics for CPU, Memory, Network
 */
class HostMetrics extends BaseMetrics_1.BaseMetrics {
    constructor() {
        super(...arguments);
        this._getMemoryData = util_1.throttle(common_1.getMemoryData, this._maxTimeoutUpdateMS);
        this._getCpuUsageData = util_1.throttle(common_1.getCpuUsageData, this._maxTimeoutUpdateMS);
        this._getNetworkData = util_1.throttle(si_1.getNetworkData, this._maxTimeoutUpdateMS);
    }
    _updateCpuTime(observableResult, cpuUsages) {
        for (let i = 0, j = cpuUsages.length; i < j; i++) {
            const cpuUsage = cpuUsages[i];
            observableResult.observe(cpuUsage.user, {
                state: enums.CPU_LABELS.USER,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.system, {
                state: enums.CPU_LABELS.SYSTEM,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.idle, {
                state: enums.CPU_LABELS.IDLE,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.interrupt, {
                state: enums.CPU_LABELS.INTERRUPT,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.nice, {
                state: enums.CPU_LABELS.NICE,
                cpu: cpuUsage.cpuNumber,
            });
        }
    }
    _updateCpuUtilisation(observableResult, cpuUsages) {
        for (let i = 0, j = cpuUsages.length; i < j; i++) {
            const cpuUsage = cpuUsages[i];
            observableResult.observe(cpuUsage.userP, {
                state: enums.CPU_LABELS.USER,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.systemP, {
                state: enums.CPU_LABELS.SYSTEM,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.idleP, {
                state: enums.CPU_LABELS.IDLE,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.interruptP, {
                state: enums.CPU_LABELS.INTERRUPT,
                cpu: cpuUsage.cpuNumber,
            });
            observableResult.observe(cpuUsage.niceP, {
                state: enums.CPU_LABELS.NICE,
                cpu: cpuUsage.cpuNumber,
            });
        }
    }
    _updateMemUsage(observableResult, memUsage) {
        observableResult.observe(memUsage.used, {
            state: enums.MEMORY_LABELS.USED,
        });
        observableResult.observe(memUsage.free, {
            state: enums.MEMORY_LABELS.FREE,
        });
    }
    _updateMemUtilization(observableResult, memUsage) {
        observableResult.observe(memUsage.usedP, {
            state: enums.MEMORY_LABELS.USED,
        });
        observableResult.observe(memUsage.freeP, {
            state: enums.MEMORY_LABELS.FREE,
        });
    }
    _updateNetworkDropped(observableResult, networkUsages) {
        for (let i = 0, j = networkUsages.length; i < j; i++) {
            const networkUsage = networkUsages[i];
            observableResult.observe(networkUsage.rx_dropped, {
                [enums.NETWORK_LABELS.DEVICE]: networkUsage.iface,
                direction: enums.NETWORK_LABELS.RECEIVE,
            });
            observableResult.observe(networkUsage.tx_dropped, {
                device: networkUsage.iface,
                direction: enums.NETWORK_LABELS.TRANSMIT,
            });
        }
    }
    _updateNetworkErrors(observableResult, networkUsages) {
        for (let i = 0, j = networkUsages.length; i < j; i++) {
            const networkUsage = networkUsages[i];
            observableResult.observe(networkUsage.rx_errors, {
                device: networkUsage.iface,
                direction: enums.NETWORK_LABELS.RECEIVE,
            });
            observableResult.observe(networkUsage.tx_errors, {
                device: networkUsage.iface,
                direction: enums.NETWORK_LABELS.TRANSMIT,
            });
        }
    }
    _updateNetworkIO(observableResult, networkUsages) {
        for (let i = 0, j = networkUsages.length; i < j; i++) {
            const networkUsage = networkUsages[i];
            observableResult.observe(networkUsage.rx_bytes, {
                device: networkUsage.iface,
                direction: enums.NETWORK_LABELS.RECEIVE,
            });
            observableResult.observe(networkUsage.tx_bytes, {
                device: networkUsage.iface,
                direction: enums.NETWORK_LABELS.TRANSMIT,
            });
        }
    }
    /**
     * Creates metrics
     */
    _createMetrics() {
        this._meter.createObservableCounter(enums.METRIC_NAMES.CPU_TIME, {
            description: 'Cpu time in seconds',
            unit: 's',
        }, observableResult => {
            const cpuUsageData = this._getCpuUsageData();
            this._updateCpuTime(observableResult, cpuUsageData);
        });
        this._meter.createObservableGauge(enums.METRIC_NAMES.CPU_UTILIZATION, {
            description: 'Cpu usage time 0-1',
        }, observableResult => {
            const cpuUsageData = this._getCpuUsageData();
            this._updateCpuUtilisation(observableResult, cpuUsageData);
        });
        this._meter.createObservableUpDownCounter(enums.METRIC_NAMES.MEMORY_USAGE, {
            description: 'Memory usage in bytes',
        }, observableResult => {
            const memoryUsageData = this._getMemoryData();
            this._updateMemUsage(observableResult, memoryUsageData);
        });
        this._meter.createObservableGauge(enums.METRIC_NAMES.MEMORY_UTILIZATION, {
            description: 'Memory usage 0-1',
        }, observableResult => {
            const memoryUsageData = this._getMemoryData();
            this._updateMemUtilization(observableResult, memoryUsageData);
        });
        this._meter.createObservableCounter(enums.METRIC_NAMES.NETWORK_DROPPED, {
            description: 'Network dropped packets',
        }, async (observableResult) => {
            const networkData = await this._getNetworkData();
            this._updateNetworkDropped(observableResult, networkData);
        });
        this._meter.createObservableCounter(enums.METRIC_NAMES.NETWORK_ERRORS, {
            description: 'Network errors counter',
        }, async (observableResult) => {
            const networkData = await this._getNetworkData();
            this._updateNetworkErrors(observableResult, networkData);
        });
        this._meter.createObservableCounter(enums.METRIC_NAMES.NETWORK_IO, {
            description: 'Network transmit and received bytes',
        }, async (observableResult) => {
            const networkData = await this._getNetworkData();
            this._updateNetworkIO(observableResult, networkData);
        });
    }
    /**
     * Starts collecting metrics
     */
    start() {
        // initial collection
        Promise.all([common_1.getMemoryData(), common_1.getCpuUsageData(), si_1.getNetworkData()]).then(() => {
            this._createMetrics();
        });
    }
}
exports.HostMetrics = HostMetrics;
//# sourceMappingURL=metric.js.map